"""Explicit statement classes generated from bind_statements_data.json."""

from __future__ import annotations

from typing import Dict, List, Optional
import re
import xml.etree.ElementTree as ET
import sys
import logging
from dwlabbasicpy import dwlabLogger
dwlabLogger.setup_logging()
logger=logging.getLogger(__name__)
__PACKAGE_NAME__ = "bind_conf"

from .bind_statements_zones import Zone, ZonePrimary, ZoneMaster, ZoneSecondary, ZoneSlave, ZoneMirror, ZoneHint, ZoneStub, ZoneStaticStub, ZoneForward, ZoneRedirect, ZoneDelegationOnly, ZoneInView, ZonePropagationDelay, ZoneStatistics
from .bind_statements_options import Options
from .bind_statements_logging import Logging
from .bind_statements_utils import _extract_statement_body, _split_statement_texts, _statement_class_for_name, _class_accepts_param





class Acl:
    statement_name = "acl"
    xml_tag = "acl"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Acl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Acl":
        function_name = sys._getframe().f_code.co_name
        class_name="Acl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Acl":
        function_name = sys._getframe().f_code.co_name
        class_name="Acl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class Algorithm:
    statement_name = "algorithm"
    xml_tag = "algorithm"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Algorithm"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Algorithm":
        function_name = sys._getframe().f_code.co_name
        class_name="Algorithm"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Algorithm":
        function_name = sys._getframe().f_code.co_name
        class_name="Algorithm"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class AllPerSecond:
    statement_name = "all-per-second"
    xml_tag = "all_per_second"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AllPerSecond"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "AllPerSecond":
        function_name = sys._getframe().f_code.co_name
        class_name="AllPerSecond"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AllPerSecond":
        function_name = sys._getframe().f_code.co_name
        class_name="AllPerSecond"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class AllowNewZones:
    statement_name = "allow-new-zones"
    xml_tag = "allow_new_zones"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AllowNewZones"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "AllowNewZones":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowNewZones"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AllowNewZones":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowNewZones"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class AllowNotify:
    statement_name = "allow-notify"
    xml_tag = "allow_notify"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AllowNotify"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "AllowNotify":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowNotify"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AllowNotify":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowNotify"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class AllowQuery:
    statement_name = "allow-query"
    xml_tag = "allow_query"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AllowQuery"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "AllowQuery":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowQuery"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AllowQuery":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowQuery"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class AllowQueryCache:
    statement_name = "allow-query-cache"
    xml_tag = "allow_query_cache"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AllowQueryCache"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "AllowQueryCache":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowQueryCache"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AllowQueryCache":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowQueryCache"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class AllowQueryCacheOn:
    statement_name = "allow-query-cache-on"
    xml_tag = "allow_query_cache_on"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AllowQueryCacheOn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "AllowQueryCacheOn":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowQueryCacheOn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AllowQueryCacheOn":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowQueryCacheOn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class AllowQueryOn:
    statement_name = "allow-query-on"
    xml_tag = "allow_query_on"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AllowQueryOn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "AllowQueryOn":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowQueryOn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AllowQueryOn":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowQueryOn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class AllowRecursion:
    statement_name = "allow-recursion"
    xml_tag = "allow_recursion"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AllowRecursion"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "AllowRecursion":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowRecursion"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AllowRecursion":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowRecursion"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class AllowRecursionOn:
    statement_name = "allow-recursion-on"
    xml_tag = "allow_recursion_on"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AllowRecursionOn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "AllowRecursionOn":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowRecursionOn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AllowRecursionOn":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowRecursionOn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class AllowTransfer:
    statement_name = "allow-transfer"
    xml_tag = "allow_transfer"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AllowTransfer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "AllowTransfer":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowTransfer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AllowTransfer":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowTransfer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class AllowUpdate:
    statement_name = "allow-update"
    xml_tag = "allow_update"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AllowUpdate"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "AllowUpdate":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowUpdate"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AllowUpdate":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowUpdate"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class AllowUpdateForwarding:
    statement_name = "allow-update-forwarding"
    xml_tag = "allow_update_forwarding"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AllowUpdateForwarding"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "AllowUpdateForwarding":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowUpdateForwarding"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AllowUpdateForwarding":
        function_name = sys._getframe().f_code.co_name
        class_name="AllowUpdateForwarding"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class AlsoNotify:
    statement_name = "also-notify"
    xml_tag = "also_notify"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AlsoNotify"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "AlsoNotify":
        function_name = sys._getframe().f_code.co_name
        class_name="AlsoNotify"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AlsoNotify":
        function_name = sys._getframe().f_code.co_name
        class_name="AlsoNotify"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class AltTransferSource:
    statement_name = "alt-transfer-source"
    xml_tag = "alt_transfer_source"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AltTransferSource"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "AltTransferSource":
        function_name = sys._getframe().f_code.co_name
        class_name="AltTransferSource"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AltTransferSource":
        function_name = sys._getframe().f_code.co_name
        class_name="AltTransferSource"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class AltTransferSourceV6:
    statement_name = "alt-transfer-source-v6"
    xml_tag = "alt_transfer_source_v6"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AltTransferSourceV6"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "AltTransferSourceV6":
        function_name = sys._getframe().f_code.co_name
        class_name="AltTransferSourceV6"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AltTransferSourceV6":
        function_name = sys._getframe().f_code.co_name
        class_name="AltTransferSourceV6"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class AnswerCookie:
    statement_name = "answer-cookie"
    xml_tag = "answer_cookie"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AnswerCookie"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "AnswerCookie":
        function_name = sys._getframe().f_code.co_name
        class_name="AnswerCookie"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AnswerCookie":
        function_name = sys._getframe().f_code.co_name
        class_name="AnswerCookie"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class AttachCache:
    statement_name = "attach-cache"
    xml_tag = "attach_cache"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AttachCache"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "AttachCache":
        function_name = sys._getframe().f_code.co_name
        class_name="AttachCache"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AttachCache":
        function_name = sys._getframe().f_code.co_name
        class_name="AttachCache"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class AuthNxdomain:
    statement_name = "auth-nxdomain"
    xml_tag = "auth_nxdomain"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AuthNxdomain"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "AuthNxdomain":
        function_name = sys._getframe().f_code.co_name
        class_name="AuthNxdomain"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AuthNxdomain":
        function_name = sys._getframe().f_code.co_name
        class_name="AuthNxdomain"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class AutoDnssec:
    statement_name = "auto-dnssec"
    xml_tag = "auto_dnssec"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AutoDnssec"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "AutoDnssec":
        function_name = sys._getframe().f_code.co_name
        class_name="AutoDnssec"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AutoDnssec":
        function_name = sys._getframe().f_code.co_name
        class_name="AutoDnssec"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class AutomaticInterfaceScan:
    statement_name = "automatic-interface-scan"
    xml_tag = "automatic_interface_scan"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AutomaticInterfaceScan"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "AutomaticInterfaceScan":
        function_name = sys._getframe().f_code.co_name
        class_name="AutomaticInterfaceScan"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AutomaticInterfaceScan":
        function_name = sys._getframe().f_code.co_name
        class_name="AutomaticInterfaceScan"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class AvoidV4UdpPorts:
    statement_name = "avoid-v4-udp-ports"
    xml_tag = "avoid_v4_udp_ports"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AvoidV4UdpPorts"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "AvoidV4UdpPorts":
        function_name = sys._getframe().f_code.co_name
        class_name="AvoidV4UdpPorts"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AvoidV4UdpPorts":
        function_name = sys._getframe().f_code.co_name
        class_name="AvoidV4UdpPorts"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class AvoidV6UdpPorts:
    statement_name = "avoid-v6-udp-ports"
    xml_tag = "avoid_v6_udp_ports"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="AvoidV6UdpPorts"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "AvoidV6UdpPorts":
        function_name = sys._getframe().f_code.co_name
        class_name="AvoidV6UdpPorts"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "AvoidV6UdpPorts":
        function_name = sys._getframe().f_code.co_name
        class_name="AvoidV6UdpPorts"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class BindkeysFile:
    statement_name = "bindkeys-file"
    xml_tag = "bindkeys_file"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="BindkeysFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "BindkeysFile":
        function_name = sys._getframe().f_code.co_name
        class_name="BindkeysFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "BindkeysFile":
        function_name = sys._getframe().f_code.co_name
        class_name="BindkeysFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Blackhole:
    statement_name = "blackhole"
    xml_tag = "blackhole"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Blackhole"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Blackhole":
        function_name = sys._getframe().f_code.co_name
        class_name="Blackhole"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Blackhole":
        function_name = sys._getframe().f_code.co_name
        class_name="Blackhole"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class Bogus:
    statement_name = "bogus"
    xml_tag = "bogus"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Bogus"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Bogus":
        function_name = sys._getframe().f_code.co_name
        class_name="Bogus"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Bogus":
        function_name = sys._getframe().f_code.co_name
        class_name="Bogus"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class BreakDnssec:
    statement_name = "break-dnssec"
    xml_tag = "break_dnssec"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="BreakDnssec"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "BreakDnssec":
        function_name = sys._getframe().f_code.co_name
        class_name="BreakDnssec"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "BreakDnssec":
        function_name = sys._getframe().f_code.co_name
        class_name="BreakDnssec"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Buffered:
    statement_name = "buffered"
    xml_tag = "buffered"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Buffered"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Buffered":
        function_name = sys._getframe().f_code.co_name
        class_name="Buffered"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Buffered":
        function_name = sys._getframe().f_code.co_name
        class_name="Buffered"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class CaFile:
    statement_name = "ca-file"
    xml_tag = "ca_file"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="CaFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "CaFile":
        function_name = sys._getframe().f_code.co_name
        class_name="CaFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "CaFile":
        function_name = sys._getframe().f_code.co_name
        class_name="CaFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class CatalogZones:
    statement_name = "catalog-zones"
    xml_tag = "catalog_zones"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="CatalogZones"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "CatalogZones":
        function_name = sys._getframe().f_code.co_name
        class_name="CatalogZones"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "CatalogZones":
        function_name = sys._getframe().f_code.co_name
        class_name="CatalogZones"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Category:
    statement_name = "category"
    xml_tag = "category"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Category"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Category":
        function_name = sys._getframe().f_code.co_name
        class_name="Category"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Category":
        function_name = sys._getframe().f_code.co_name
        class_name="Category"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class CertFile:
    statement_name = "cert-file"
    xml_tag = "cert_file"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="CertFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "CertFile":
        function_name = sys._getframe().f_code.co_name
        class_name="CertFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "CertFile":
        function_name = sys._getframe().f_code.co_name
        class_name="CertFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Channel:
    statement_name = "channel"
    xml_tag = "channel"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Channel"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Channel":
        function_name = sys._getframe().f_code.co_name
        class_name="Channel"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Channel":
        function_name = sys._getframe().f_code.co_name
        class_name="Channel"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class CheckDupRecords:
    statement_name = "check-dup-records"
    xml_tag = "check_dup_records"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="CheckDupRecords"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "CheckDupRecords":
        function_name = sys._getframe().f_code.co_name
        class_name="CheckDupRecords"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "CheckDupRecords":
        function_name = sys._getframe().f_code.co_name
        class_name="CheckDupRecords"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class CheckIntegrity:
    statement_name = "check-integrity"
    xml_tag = "check_integrity"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="CheckIntegrity"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "CheckIntegrity":
        function_name = sys._getframe().f_code.co_name
        class_name="CheckIntegrity"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "CheckIntegrity":
        function_name = sys._getframe().f_code.co_name
        class_name="CheckIntegrity"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class CheckMx:
    statement_name = "check-mx"
    xml_tag = "check_mx"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="CheckMx"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "CheckMx":
        function_name = sys._getframe().f_code.co_name
        class_name="CheckMx"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "CheckMx":
        function_name = sys._getframe().f_code.co_name
        class_name="CheckMx"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class CheckMxCname:
    statement_name = "check-mx-cname"
    xml_tag = "check_mx_cname"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="CheckMxCname"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "CheckMxCname":
        function_name = sys._getframe().f_code.co_name
        class_name="CheckMxCname"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "CheckMxCname":
        function_name = sys._getframe().f_code.co_name
        class_name="CheckMxCname"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class CheckNames:
    statement_name = "check-names"
    xml_tag = "check_names"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="CheckNames"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "CheckNames":
        function_name = sys._getframe().f_code.co_name
        class_name="CheckNames"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "CheckNames":
        function_name = sys._getframe().f_code.co_name
        class_name="CheckNames"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class CheckSibling:
    statement_name = "check-sibling"
    xml_tag = "check_sibling"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="CheckSibling"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "CheckSibling":
        function_name = sys._getframe().f_code.co_name
        class_name="CheckSibling"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "CheckSibling":
        function_name = sys._getframe().f_code.co_name
        class_name="CheckSibling"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class CheckSpf:
    statement_name = "check-spf"
    xml_tag = "check_spf"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="CheckSpf"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "CheckSpf":
        function_name = sys._getframe().f_code.co_name
        class_name="CheckSpf"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "CheckSpf":
        function_name = sys._getframe().f_code.co_name
        class_name="CheckSpf"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class CheckSrvCname:
    statement_name = "check-srv-cname"
    xml_tag = "check_srv_cname"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="CheckSrvCname"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "CheckSrvCname":
        function_name = sys._getframe().f_code.co_name
        class_name="CheckSrvCname"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "CheckSrvCname":
        function_name = sys._getframe().f_code.co_name
        class_name="CheckSrvCname"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class CheckWildcard:
    statement_name = "check-wildcard"
    xml_tag = "check_wildcard"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="CheckWildcard"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "CheckWildcard":
        function_name = sys._getframe().f_code.co_name
        class_name="CheckWildcard"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "CheckWildcard":
        function_name = sys._getframe().f_code.co_name
        class_name="CheckWildcard"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Ciphers:
    statement_name = "ciphers"
    xml_tag = "ciphers"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Ciphers"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Ciphers":
        function_name = sys._getframe().f_code.co_name
        class_name="Ciphers"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Ciphers":
        function_name = sys._getframe().f_code.co_name
        class_name="Ciphers"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Clients:
    statement_name = "clients"
    xml_tag = "clients"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Clients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Clients":
        function_name = sys._getframe().f_code.co_name
        class_name="Clients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Clients":
        function_name = sys._getframe().f_code.co_name
        class_name="Clients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class ClientsPerQuery:
    statement_name = "clients-per-query"
    xml_tag = "clients_per_query"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ClientsPerQuery"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "ClientsPerQuery":
        function_name = sys._getframe().f_code.co_name
        class_name="ClientsPerQuery"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ClientsPerQuery":
        function_name = sys._getframe().f_code.co_name
        class_name="ClientsPerQuery"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Controls:
    statement_name = "controls"
    ALLOWED_STATEMENTS = [
        "inet",
        "unix",
    ]

    xml_tag = "controls"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Controls"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Controls":
        function_name = sys._getframe().f_code.co_name
        class_name="Controls"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Controls":
        function_name = sys._getframe().f_code.co_name
        class_name="Controls"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class CookieAlgorithm:
    statement_name = "cookie-algorithm"
    xml_tag = "cookie_algorithm"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="CookieAlgorithm"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "CookieAlgorithm":
        function_name = sys._getframe().f_code.co_name
        class_name="CookieAlgorithm"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "CookieAlgorithm":
        function_name = sys._getframe().f_code.co_name
        class_name="CookieAlgorithm"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class CookieSecret:
    statement_name = "cookie-secret"
    xml_tag = "cookie_secret"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="CookieSecret"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "CookieSecret":
        function_name = sys._getframe().f_code.co_name
        class_name="CookieSecret"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "CookieSecret":
        function_name = sys._getframe().f_code.co_name
        class_name="CookieSecret"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Coresize:
    statement_name = "coresize"
    xml_tag = "coresize"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Coresize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Coresize":
        function_name = sys._getframe().f_code.co_name
        class_name="Coresize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Coresize":
        function_name = sys._getframe().f_code.co_name
        class_name="Coresize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Database:
    statement_name = "database"
    xml_tag = "database"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Database"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Database":
        function_name = sys._getframe().f_code.co_name
        class_name="Database"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Database":
        function_name = sys._getframe().f_code.co_name
        class_name="Database"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Datasize:
    statement_name = "datasize"
    xml_tag = "datasize"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Datasize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Datasize":
        function_name = sys._getframe().f_code.co_name
        class_name="Datasize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Datasize":
        function_name = sys._getframe().f_code.co_name
        class_name="Datasize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class DelegationOnly:
    statement_name = "delegation-only"
    xml_tag = "delegation_only"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DelegationOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "DelegationOnly":
        function_name = sys._getframe().f_code.co_name
        class_name="DelegationOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DelegationOnly":
        function_name = sys._getframe().f_code.co_name
        class_name="DelegationOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class DenyAnswerAddresses:
    statement_name = "deny-answer-addresses"
    xml_tag = "deny_answer_addresses"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DenyAnswerAddresses"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "DenyAnswerAddresses":
        function_name = sys._getframe().f_code.co_name
        class_name="DenyAnswerAddresses"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DenyAnswerAddresses":
        function_name = sys._getframe().f_code.co_name
        class_name="DenyAnswerAddresses"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class DenyAnswerAliases:
    statement_name = "deny-answer-aliases"
    xml_tag = "deny_answer_aliases"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DenyAnswerAliases"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "DenyAnswerAliases":
        function_name = sys._getframe().f_code.co_name
        class_name="DenyAnswerAliases"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DenyAnswerAliases":
        function_name = sys._getframe().f_code.co_name
        class_name="DenyAnswerAliases"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class DhparamFile:
    statement_name = "dhparam-file"
    xml_tag = "dhparam_file"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DhparamFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "DhparamFile":
        function_name = sys._getframe().f_code.co_name
        class_name="DhparamFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DhparamFile":
        function_name = sys._getframe().f_code.co_name
        class_name="DhparamFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Dialup:
    statement_name = "dialup"
    xml_tag = "dialup"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Dialup"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Dialup":
        function_name = sys._getframe().f_code.co_name
        class_name="Dialup"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Dialup":
        function_name = sys._getframe().f_code.co_name
        class_name="Dialup"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Directory:
    statement_name = "directory"
    xml_tag = "directory"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Directory"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Directory":
        function_name = sys._getframe().f_code.co_name
        class_name="Directory"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Directory":
        function_name = sys._getframe().f_code.co_name
        class_name="Directory"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class DisableAlgorithms:
    statement_name = "disable-algorithms"
    xml_tag = "disable_algorithms"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DisableAlgorithms"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "DisableAlgorithms":
        function_name = sys._getframe().f_code.co_name
        class_name="DisableAlgorithms"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DisableAlgorithms":
        function_name = sys._getframe().f_code.co_name
        class_name="DisableAlgorithms"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class DisableDsDigests:
    statement_name = "disable-ds-digests"
    xml_tag = "disable_ds_digests"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DisableDsDigests"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "DisableDsDigests":
        function_name = sys._getframe().f_code.co_name
        class_name="DisableDsDigests"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DisableDsDigests":
        function_name = sys._getframe().f_code.co_name
        class_name="DisableDsDigests"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class DisableEmptyZone:
    statement_name = "disable-empty-zone"
    xml_tag = "disable_empty_zone"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DisableEmptyZone"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "DisableEmptyZone":
        function_name = sys._getframe().f_code.co_name
        class_name="DisableEmptyZone"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DisableEmptyZone":
        function_name = sys._getframe().f_code.co_name
        class_name="DisableEmptyZone"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Dlz:
    statement_name = "dlz"
    ALLOWED_STATEMENTS = [
        "database",
    ]

    xml_tag = "dlz"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Dlz"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Dlz":
        function_name = sys._getframe().f_code.co_name
        class_name="Dlz"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Dlz":
        function_name = sys._getframe().f_code.co_name
        class_name="Dlz"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Dns64:
    statement_name = "dns64"
    xml_tag = "dns64"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Dns64"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Dns64":
        function_name = sys._getframe().f_code.co_name
        class_name="Dns64"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Dns64":
        function_name = sys._getframe().f_code.co_name
        class_name="Dns64"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class Dns64Contact:
    statement_name = "dns64-contact"
    xml_tag = "dns64_contact"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Dns64Contact"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Dns64Contact":
        function_name = sys._getframe().f_code.co_name
        class_name="Dns64Contact"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Dns64Contact":
        function_name = sys._getframe().f_code.co_name
        class_name="Dns64Contact"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Dns64Server:
    statement_name = "dns64-server"
    xml_tag = "dns64_server"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Dns64Server"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Dns64Server":
        function_name = sys._getframe().f_code.co_name
        class_name="Dns64Server"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Dns64Server":
        function_name = sys._getframe().f_code.co_name
        class_name="Dns64Server"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class DnskeySigValidity:
    statement_name = "dnskey-sig-validity"
    xml_tag = "dnskey_sig_validity"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DnskeySigValidity"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "DnskeySigValidity":
        function_name = sys._getframe().f_code.co_name
        class_name="DnskeySigValidity"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DnskeySigValidity":
        function_name = sys._getframe().f_code.co_name
        class_name="DnskeySigValidity"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class DnskeyTtl:
    statement_name = "dnskey-ttl"
    xml_tag = "dnskey_ttl"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DnskeyTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "DnskeyTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="DnskeyTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DnskeyTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="DnskeyTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class DnsrpsEnable:
    statement_name = "dnsrps-enable"
    xml_tag = "dnsrps_enable"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DnsrpsEnable"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "DnsrpsEnable":
        function_name = sys._getframe().f_code.co_name
        class_name="DnsrpsEnable"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DnsrpsEnable":
        function_name = sys._getframe().f_code.co_name
        class_name="DnsrpsEnable"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class DnsrpsOptions:
    statement_name = "dnsrps-options"
    xml_tag = "dnsrps_options"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DnsrpsOptions"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "DnsrpsOptions":
        function_name = sys._getframe().f_code.co_name
        class_name="DnsrpsOptions"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DnsrpsOptions":
        function_name = sys._getframe().f_code.co_name
        class_name="DnsrpsOptions"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class DnssecAcceptExpired:
    statement_name = "dnssec-accept-expired"
    xml_tag = "dnssec_accept_expired"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecAcceptExpired"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "DnssecAcceptExpired":
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecAcceptExpired"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DnssecAcceptExpired":
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecAcceptExpired"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class DnssecDnskeyKskonly:
    statement_name = "dnssec-dnskey-kskonly"
    xml_tag = "dnssec_dnskey_kskonly"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecDnskeyKskonly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "DnssecDnskeyKskonly":
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecDnskeyKskonly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DnssecDnskeyKskonly":
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecDnskeyKskonly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class DnssecLoadkeysInterval:
    statement_name = "dnssec-loadkeys-interval"
    xml_tag = "dnssec_loadkeys_interval"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecLoadkeysInterval"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "DnssecLoadkeysInterval":
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecLoadkeysInterval"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DnssecLoadkeysInterval":
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecLoadkeysInterval"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class DnssecMustBeSecure:
    statement_name = "dnssec-must-be-secure"
    xml_tag = "dnssec_must_be_secure"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecMustBeSecure"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "DnssecMustBeSecure":
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecMustBeSecure"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DnssecMustBeSecure":
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecMustBeSecure"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class DnssecPolicy:
    statement_name = "dnssec-policy"
    ALLOWED_STATEMENTS = [
        "dnskey-ttl",
        "keys",
        "max-zone-ttl",
        "nsec3param",
        "parent-ds-ttl",
        "parent-propagation-delay",
        "publish-safety",
        "purge-keys",
        "retire-safety",
        "signatures-refresh",
        "signatures-validity",
        "signatures-validity-dnskey",
        "zone-propagation-delay",
    ]

    xml_tag = "dnssec_policy"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecPolicy"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "DnssecPolicy":
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecPolicy"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DnssecPolicy":
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecPolicy"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class DnssecSecureToInsecure:
    statement_name = "dnssec-secure-to-insecure"
    xml_tag = "dnssec_secure_to_insecure"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecSecureToInsecure"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "DnssecSecureToInsecure":
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecSecureToInsecure"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DnssecSecureToInsecure":
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecSecureToInsecure"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class DnssecUpdateMode:
    statement_name = "dnssec-update-mode"
    xml_tag = "dnssec_update_mode"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecUpdateMode"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "DnssecUpdateMode":
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecUpdateMode"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DnssecUpdateMode":
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecUpdateMode"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class DnssecValidation:
    statement_name = "dnssec-validation"
    xml_tag = "dnssec_validation"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecValidation"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "DnssecValidation":
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecValidation"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DnssecValidation":
        function_name = sys._getframe().f_code.co_name
        class_name="DnssecValidation"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Dnstap:
    statement_name = "dnstap"
    xml_tag = "dnstap"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Dnstap"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Dnstap":
        function_name = sys._getframe().f_code.co_name
        class_name="Dnstap"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Dnstap":
        function_name = sys._getframe().f_code.co_name
        class_name="Dnstap"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class DnstapIdentity:
    statement_name = "dnstap-identity"
    xml_tag = "dnstap_identity"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DnstapIdentity"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "DnstapIdentity":
        function_name = sys._getframe().f_code.co_name
        class_name="DnstapIdentity"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DnstapIdentity":
        function_name = sys._getframe().f_code.co_name
        class_name="DnstapIdentity"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class DnstapOutput:
    statement_name = "dnstap-output"
    xml_tag = "dnstap_output"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DnstapOutput"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "DnstapOutput":
        function_name = sys._getframe().f_code.co_name
        class_name="DnstapOutput"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DnstapOutput":
        function_name = sys._getframe().f_code.co_name
        class_name="DnstapOutput"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class DnstapVersion:
    statement_name = "dnstap-version"
    xml_tag = "dnstap_version"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DnstapVersion"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "DnstapVersion":
        function_name = sys._getframe().f_code.co_name
        class_name="DnstapVersion"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DnstapVersion":
        function_name = sys._getframe().f_code.co_name
        class_name="DnstapVersion"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Dscp:
    statement_name = "dscp"
    xml_tag = "dscp"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Dscp"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Dscp":
        function_name = sys._getframe().f_code.co_name
        class_name="Dscp"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Dscp":
        function_name = sys._getframe().f_code.co_name
        class_name="Dscp"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class DualStackServers:
    statement_name = "dual-stack-servers"
    xml_tag = "dual_stack_servers"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DualStackServers"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "DualStackServers":
        function_name = sys._getframe().f_code.co_name
        class_name="DualStackServers"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DualStackServers":
        function_name = sys._getframe().f_code.co_name
        class_name="DualStackServers"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class DumpFile:
    statement_name = "dump-file"
    xml_tag = "dump_file"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="DumpFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "DumpFile":
        function_name = sys._getframe().f_code.co_name
        class_name="DumpFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "DumpFile":
        function_name = sys._getframe().f_code.co_name
        class_name="DumpFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Dyndb:
    statement_name = "dyndb"
    xml_tag = "dyndb"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Dyndb"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Dyndb":
        function_name = sys._getframe().f_code.co_name
        class_name="Dyndb"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Dyndb":
        function_name = sys._getframe().f_code.co_name
        class_name="Dyndb"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Edns:
    statement_name = "edns"
    xml_tag = "edns"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Edns"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Edns":
        function_name = sys._getframe().f_code.co_name
        class_name="Edns"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Edns":
        function_name = sys._getframe().f_code.co_name
        class_name="Edns"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class EdnsUdpSize:
    statement_name = "edns-udp-size"
    xml_tag = "edns_udp_size"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="EdnsUdpSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "EdnsUdpSize":
        function_name = sys._getframe().f_code.co_name
        class_name="EdnsUdpSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "EdnsUdpSize":
        function_name = sys._getframe().f_code.co_name
        class_name="EdnsUdpSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class EdnsVersion:
    statement_name = "edns-version"
    xml_tag = "edns_version"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="EdnsVersion"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "EdnsVersion":
        function_name = sys._getframe().f_code.co_name
        class_name="EdnsVersion"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "EdnsVersion":
        function_name = sys._getframe().f_code.co_name
        class_name="EdnsVersion"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class EmptyContact:
    statement_name = "empty-contact"
    xml_tag = "empty_contact"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="EmptyContact"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "EmptyContact":
        function_name = sys._getframe().f_code.co_name
        class_name="EmptyContact"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "EmptyContact":
        function_name = sys._getframe().f_code.co_name
        class_name="EmptyContact"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class EmptyServer:
    statement_name = "empty-server"
    xml_tag = "empty_server"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="EmptyServer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "EmptyServer":
        function_name = sys._getframe().f_code.co_name
        class_name="EmptyServer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "EmptyServer":
        function_name = sys._getframe().f_code.co_name
        class_name="EmptyServer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class EmptyZonesEnable:
    statement_name = "empty-zones-enable"
    xml_tag = "empty_zones_enable"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="EmptyZonesEnable"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "EmptyZonesEnable":
        function_name = sys._getframe().f_code.co_name
        class_name="EmptyZonesEnable"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "EmptyZonesEnable":
        function_name = sys._getframe().f_code.co_name
        class_name="EmptyZonesEnable"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Endpoints:
    statement_name = "endpoints"
    xml_tag = "endpoints"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Endpoints"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Endpoints":
        function_name = sys._getframe().f_code.co_name
        class_name="Endpoints"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Endpoints":
        function_name = sys._getframe().f_code.co_name
        class_name="Endpoints"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class ErrorsPerSecond:
    statement_name = "errors-per-second"
    xml_tag = "errors_per_second"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ErrorsPerSecond"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "ErrorsPerSecond":
        function_name = sys._getframe().f_code.co_name
        class_name="ErrorsPerSecond"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ErrorsPerSecond":
        function_name = sys._getframe().f_code.co_name
        class_name="ErrorsPerSecond"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Exclude:
    statement_name = "exclude"
    xml_tag = "exclude"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Exclude"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Exclude":
        function_name = sys._getframe().f_code.co_name
        class_name="Exclude"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Exclude":
        function_name = sys._getframe().f_code.co_name
        class_name="Exclude"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class ExemptClients:
    statement_name = "exempt-clients"
    xml_tag = "exempt_clients"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ExemptClients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "ExemptClients":
        function_name = sys._getframe().f_code.co_name
        class_name="ExemptClients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ExemptClients":
        function_name = sys._getframe().f_code.co_name
        class_name="ExemptClients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class FetchQuotaParams:
    statement_name = "fetch-quota-params"
    xml_tag = "fetch_quota_params"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="FetchQuotaParams"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "FetchQuotaParams":
        function_name = sys._getframe().f_code.co_name
        class_name="FetchQuotaParams"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "FetchQuotaParams":
        function_name = sys._getframe().f_code.co_name
        class_name="FetchQuotaParams"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class FetchesPerServer:
    statement_name = "fetches-per-server"
    xml_tag = "fetches_per_server"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="FetchesPerServer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "FetchesPerServer":
        function_name = sys._getframe().f_code.co_name
        class_name="FetchesPerServer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "FetchesPerServer":
        function_name = sys._getframe().f_code.co_name
        class_name="FetchesPerServer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class FetchesPerZone:
    statement_name = "fetches-per-zone"
    xml_tag = "fetches_per_zone"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="FetchesPerZone"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "FetchesPerZone":
        function_name = sys._getframe().f_code.co_name
        class_name="FetchesPerZone"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "FetchesPerZone":
        function_name = sys._getframe().f_code.co_name
        class_name="FetchesPerZone"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class File:
    statement_name = "file"
    xml_tag = "file"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="File"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "File":
        function_name = sys._getframe().f_code.co_name
        class_name="File"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "File":
        function_name = sys._getframe().f_code.co_name
        class_name="File"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Files:
    statement_name = "files"
    xml_tag = "files"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Files"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Files":
        function_name = sys._getframe().f_code.co_name
        class_name="Files"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Files":
        function_name = sys._getframe().f_code.co_name
        class_name="Files"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class FlushZonesOnShutdown:
    statement_name = "flush-zones-on-shutdown"
    xml_tag = "flush_zones_on_shutdown"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="FlushZonesOnShutdown"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "FlushZonesOnShutdown":
        function_name = sys._getframe().f_code.co_name
        class_name="FlushZonesOnShutdown"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "FlushZonesOnShutdown":
        function_name = sys._getframe().f_code.co_name
        class_name="FlushZonesOnShutdown"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Forward:
    statement_name = "forward"
    xml_tag = "forward"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Forward"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Forward":
        function_name = sys._getframe().f_code.co_name
        class_name="Forward"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Forward":
        function_name = sys._getframe().f_code.co_name
        class_name="Forward"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Forwarders:
    statement_name = "forwarders"
    xml_tag = "forwarders"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Forwarders"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Forwarders":
        function_name = sys._getframe().f_code.co_name
        class_name="Forwarders"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Forwarders":
        function_name = sys._getframe().f_code.co_name
        class_name="Forwarders"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class FstrmSetBufferHint:
    statement_name = "fstrm-set-buffer-hint"
    xml_tag = "fstrm_set_buffer_hint"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetBufferHint"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "FstrmSetBufferHint":
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetBufferHint"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "FstrmSetBufferHint":
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetBufferHint"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class FstrmSetFlushTimeout:
    statement_name = "fstrm-set-flush-timeout"
    xml_tag = "fstrm_set_flush_timeout"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetFlushTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "FstrmSetFlushTimeout":
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetFlushTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "FstrmSetFlushTimeout":
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetFlushTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class FstrmSetInputQueueSize:
    statement_name = "fstrm-set-input-queue-size"
    xml_tag = "fstrm_set_input_queue_size"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetInputQueueSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "FstrmSetInputQueueSize":
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetInputQueueSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "FstrmSetInputQueueSize":
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetInputQueueSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class FstrmSetOutputNotifyThreshold:
    statement_name = "fstrm-set-output-notify-threshold"
    xml_tag = "fstrm_set_output_notify_threshold"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetOutputNotifyThreshold"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "FstrmSetOutputNotifyThreshold":
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetOutputNotifyThreshold"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "FstrmSetOutputNotifyThreshold":
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetOutputNotifyThreshold"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class FstrmSetOutputQueueModel:
    statement_name = "fstrm-set-output-queue-model"
    xml_tag = "fstrm_set_output_queue_model"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetOutputQueueModel"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "FstrmSetOutputQueueModel":
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetOutputQueueModel"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "FstrmSetOutputQueueModel":
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetOutputQueueModel"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class FstrmSetOutputQueueSize:
    statement_name = "fstrm-set-output-queue-size"
    xml_tag = "fstrm_set_output_queue_size"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetOutputQueueSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "FstrmSetOutputQueueSize":
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetOutputQueueSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "FstrmSetOutputQueueSize":
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetOutputQueueSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class FstrmSetReopenInterval:
    statement_name = "fstrm-set-reopen-interval"
    xml_tag = "fstrm_set_reopen_interval"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetReopenInterval"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "FstrmSetReopenInterval":
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetReopenInterval"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "FstrmSetReopenInterval":
        function_name = sys._getframe().f_code.co_name
        class_name="FstrmSetReopenInterval"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class GeoipDirectory:
    statement_name = "geoip-directory"
    xml_tag = "geoip_directory"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="GeoipDirectory"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "GeoipDirectory":
        function_name = sys._getframe().f_code.co_name
        class_name="GeoipDirectory"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "GeoipDirectory":
        function_name = sys._getframe().f_code.co_name
        class_name="GeoipDirectory"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class GlueCache:
    statement_name = "glue-cache"
    xml_tag = "glue_cache"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="GlueCache"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "GlueCache":
        function_name = sys._getframe().f_code.co_name
        class_name="GlueCache"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "GlueCache":
        function_name = sys._getframe().f_code.co_name
        class_name="GlueCache"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class HeartbeatInterval:
    statement_name = "heartbeat-interval"
    xml_tag = "heartbeat_interval"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="HeartbeatInterval"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "HeartbeatInterval":
        function_name = sys._getframe().f_code.co_name
        class_name="HeartbeatInterval"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "HeartbeatInterval":
        function_name = sys._getframe().f_code.co_name
        class_name="HeartbeatInterval"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Hostname:
    statement_name = "hostname"
    xml_tag = "hostname"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Hostname"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Hostname":
        function_name = sys._getframe().f_code.co_name
        class_name="Hostname"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Hostname":
        function_name = sys._getframe().f_code.co_name
        class_name="Hostname"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Http:
    statement_name = "http"
    ALLOWED_STATEMENTS = [
        "endpoints",
        "listener-clients",
        "streams-per-connection",
    ]

    xml_tag = "http"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Http"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Http":
        function_name = sys._getframe().f_code.co_name
        class_name="Http"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Http":
        function_name = sys._getframe().f_code.co_name
        class_name="Http"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class HttpListenerClients:
    statement_name = "http-listener-clients"
    xml_tag = "http_listener_clients"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="HttpListenerClients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "HttpListenerClients":
        function_name = sys._getframe().f_code.co_name
        class_name="HttpListenerClients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "HttpListenerClients":
        function_name = sys._getframe().f_code.co_name
        class_name="HttpListenerClients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class HttpPort:
    statement_name = "http-port"
    xml_tag = "http_port"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="HttpPort"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "HttpPort":
        function_name = sys._getframe().f_code.co_name
        class_name="HttpPort"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "HttpPort":
        function_name = sys._getframe().f_code.co_name
        class_name="HttpPort"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class HttpStreamsPerConnection:
    statement_name = "http-streams-per-connection"
    xml_tag = "http_streams_per_connection"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="HttpStreamsPerConnection"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "HttpStreamsPerConnection":
        function_name = sys._getframe().f_code.co_name
        class_name="HttpStreamsPerConnection"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "HttpStreamsPerConnection":
        function_name = sys._getframe().f_code.co_name
        class_name="HttpStreamsPerConnection"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class HttpsPort:
    statement_name = "https-port"
    xml_tag = "https_port"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="HttpsPort"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "HttpsPort":
        function_name = sys._getframe().f_code.co_name
        class_name="HttpsPort"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "HttpsPort":
        function_name = sys._getframe().f_code.co_name
        class_name="HttpsPort"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class InView:
    statement_name = "in-view"
    xml_tag = "in_view"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="InView"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "InView":
        function_name = sys._getframe().f_code.co_name
        class_name="InView"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "InView":
        function_name = sys._getframe().f_code.co_name
        class_name="InView"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Inet:
    statement_name = "inet"
    xml_tag = "inet"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Inet"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Inet":
        function_name = sys._getframe().f_code.co_name
        class_name="Inet"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Inet":
        function_name = sys._getframe().f_code.co_name
        class_name="Inet"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class InlineSigning:
    statement_name = "inline-signing"
    xml_tag = "inline_signing"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="InlineSigning"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "InlineSigning":
        function_name = sys._getframe().f_code.co_name
        class_name="InlineSigning"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "InlineSigning":
        function_name = sys._getframe().f_code.co_name
        class_name="InlineSigning"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class InterfaceInterval:
    statement_name = "interface-interval"
    xml_tag = "interface_interval"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="InterfaceInterval"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "InterfaceInterval":
        function_name = sys._getframe().f_code.co_name
        class_name="InterfaceInterval"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "InterfaceInterval":
        function_name = sys._getframe().f_code.co_name
        class_name="InterfaceInterval"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Ipv4PrefixLength:
    statement_name = "ipv4-prefix-length"
    xml_tag = "ipv4_prefix_length"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Ipv4PrefixLength"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Ipv4PrefixLength":
        function_name = sys._getframe().f_code.co_name
        class_name="Ipv4PrefixLength"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Ipv4PrefixLength":
        function_name = sys._getframe().f_code.co_name
        class_name="Ipv4PrefixLength"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Ipv4onlyContact:
    statement_name = "ipv4only-contact"
    xml_tag = "ipv4only_contact"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Ipv4onlyContact"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Ipv4onlyContact":
        function_name = sys._getframe().f_code.co_name
        class_name="Ipv4onlyContact"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Ipv4onlyContact":
        function_name = sys._getframe().f_code.co_name
        class_name="Ipv4onlyContact"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Ipv4onlyEnable:
    statement_name = "ipv4only-enable"
    xml_tag = "ipv4only_enable"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Ipv4onlyEnable"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Ipv4onlyEnable":
        function_name = sys._getframe().f_code.co_name
        class_name="Ipv4onlyEnable"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Ipv4onlyEnable":
        function_name = sys._getframe().f_code.co_name
        class_name="Ipv4onlyEnable"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Ipv4onlyServer:
    statement_name = "ipv4only-server"
    xml_tag = "ipv4only_server"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Ipv4onlyServer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Ipv4onlyServer":
        function_name = sys._getframe().f_code.co_name
        class_name="Ipv4onlyServer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Ipv4onlyServer":
        function_name = sys._getframe().f_code.co_name
        class_name="Ipv4onlyServer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Ipv6PrefixLength:
    statement_name = "ipv6-prefix-length"
    xml_tag = "ipv6_prefix_length"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Ipv6PrefixLength"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Ipv6PrefixLength":
        function_name = sys._getframe().f_code.co_name
        class_name="Ipv6PrefixLength"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Ipv6PrefixLength":
        function_name = sys._getframe().f_code.co_name
        class_name="Ipv6PrefixLength"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class IxfrFromDifferences:
    statement_name = "ixfr-from-differences"
    xml_tag = "ixfr_from_differences"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="IxfrFromDifferences"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "IxfrFromDifferences":
        function_name = sys._getframe().f_code.co_name
        class_name="IxfrFromDifferences"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "IxfrFromDifferences":
        function_name = sys._getframe().f_code.co_name
        class_name="IxfrFromDifferences"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Journal:
    statement_name = "journal"
    xml_tag = "journal"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Journal"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Journal":
        function_name = sys._getframe().f_code.co_name
        class_name="Journal"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Journal":
        function_name = sys._getframe().f_code.co_name
        class_name="Journal"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class KeepResponseOrder:
    statement_name = "keep-response-order"
    xml_tag = "keep_response_order"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="KeepResponseOrder"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "KeepResponseOrder":
        function_name = sys._getframe().f_code.co_name
        class_name="KeepResponseOrder"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "KeepResponseOrder":
        function_name = sys._getframe().f_code.co_name
        class_name="KeepResponseOrder"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class Key:
    statement_name = "key"
    ALLOWED_STATEMENTS = [
        "algorithm",
        "secret",
    ]

    xml_tag = "key"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Key"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Key":
        function_name = sys._getframe().f_code.co_name
        class_name="Key"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Key":
        function_name = sys._getframe().f_code.co_name
        class_name="Key"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class KeyDirectory:
    statement_name = "key-directory"
    xml_tag = "key_directory"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="KeyDirectory"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "KeyDirectory":
        function_name = sys._getframe().f_code.co_name
        class_name="KeyDirectory"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "KeyDirectory":
        function_name = sys._getframe().f_code.co_name
        class_name="KeyDirectory"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class KeyFile:
    statement_name = "key-file"
    xml_tag = "key_file"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="KeyFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "KeyFile":
        function_name = sys._getframe().f_code.co_name
        class_name="KeyFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "KeyFile":
        function_name = sys._getframe().f_code.co_name
        class_name="KeyFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Keys:
    statement_name = "keys"
    xml_tag = "keys"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Keys"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Keys":
        function_name = sys._getframe().f_code.co_name
        class_name="Keys"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Keys":
        function_name = sys._getframe().f_code.co_name
        class_name="Keys"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class LameTtl:
    statement_name = "lame-ttl"
    xml_tag = "lame_ttl"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="LameTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "LameTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="LameTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "LameTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="LameTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class ListenOn:
    statement_name = "listen-on"
    xml_tag = "listen_on"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ListenOn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "ListenOn":
        function_name = sys._getframe().f_code.co_name
        class_name="ListenOn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ListenOn":
        function_name = sys._getframe().f_code.co_name
        class_name="ListenOn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class ListenOnV6:
    statement_name = "listen-on-v6"
    xml_tag = "listen_on_v6"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ListenOnV6"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "ListenOnV6":
        function_name = sys._getframe().f_code.co_name
        class_name="ListenOnV6"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ListenOnV6":
        function_name = sys._getframe().f_code.co_name
        class_name="ListenOnV6"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class ListenerClients:
    statement_name = "listener-clients"
    xml_tag = "listener_clients"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ListenerClients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "ListenerClients":
        function_name = sys._getframe().f_code.co_name
        class_name="ListenerClients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ListenerClients":
        function_name = sys._getframe().f_code.co_name
        class_name="ListenerClients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class LmdbMapsize:
    statement_name = "lmdb-mapsize"
    xml_tag = "lmdb_mapsize"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="LmdbMapsize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "LmdbMapsize":
        function_name = sys._getframe().f_code.co_name
        class_name="LmdbMapsize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "LmdbMapsize":
        function_name = sys._getframe().f_code.co_name
        class_name="LmdbMapsize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class LockFile:
    statement_name = "lock-file"
    xml_tag = "lock_file"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="LockFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "LockFile":
        function_name = sys._getframe().f_code.co_name
        class_name="LockFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "LockFile":
        function_name = sys._getframe().f_code.co_name
        class_name="LockFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class LogOnly:
    statement_name = "log-only"
    xml_tag = "log_only"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="LogOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "LogOnly":
        function_name = sys._getframe().f_code.co_name
        class_name="LogOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "LogOnly":
        function_name = sys._getframe().f_code.co_name
        class_name="LogOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class ManagedKeys:
    statement_name = "managed-keys"
    xml_tag = "managed_keys"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ManagedKeys"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "ManagedKeys":
        function_name = sys._getframe().f_code.co_name
        class_name="ManagedKeys"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ManagedKeys":
        function_name = sys._getframe().f_code.co_name
        class_name="ManagedKeys"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class ManagedKeysDirectory:
    statement_name = "managed-keys-directory"
    xml_tag = "managed_keys_directory"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ManagedKeysDirectory"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "ManagedKeysDirectory":
        function_name = sys._getframe().f_code.co_name
        class_name="ManagedKeysDirectory"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ManagedKeysDirectory":
        function_name = sys._getframe().f_code.co_name
        class_name="ManagedKeysDirectory"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Mapped:
    statement_name = "mapped"
    xml_tag = "mapped"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Mapped"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Mapped":
        function_name = sys._getframe().f_code.co_name
        class_name="Mapped"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Mapped":
        function_name = sys._getframe().f_code.co_name
        class_name="Mapped"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class MasterfileFormat:
    statement_name = "masterfile-format"
    xml_tag = "masterfile_format"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MasterfileFormat"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MasterfileFormat":
        function_name = sys._getframe().f_code.co_name
        class_name="MasterfileFormat"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MasterfileFormat":
        function_name = sys._getframe().f_code.co_name
        class_name="MasterfileFormat"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MasterfileStyle:
    statement_name = "masterfile-style"
    xml_tag = "masterfile_style"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MasterfileStyle"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MasterfileStyle":
        function_name = sys._getframe().f_code.co_name
        class_name="MasterfileStyle"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MasterfileStyle":
        function_name = sys._getframe().f_code.co_name
        class_name="MasterfileStyle"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MatchClients:
    statement_name = "match-clients"
    xml_tag = "match_clients"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MatchClients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "MatchClients":
        function_name = sys._getframe().f_code.co_name
        class_name="MatchClients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MatchClients":
        function_name = sys._getframe().f_code.co_name
        class_name="MatchClients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class MatchDestinations:
    statement_name = "match-destinations"
    xml_tag = "match_destinations"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MatchDestinations"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "MatchDestinations":
        function_name = sys._getframe().f_code.co_name
        class_name="MatchDestinations"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MatchDestinations":
        function_name = sys._getframe().f_code.co_name
        class_name="MatchDestinations"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class MatchMappedAddresses:
    statement_name = "match-mapped-addresses"
    xml_tag = "match_mapped_addresses"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MatchMappedAddresses"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MatchMappedAddresses":
        function_name = sys._getframe().f_code.co_name
        class_name="MatchMappedAddresses"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MatchMappedAddresses":
        function_name = sys._getframe().f_code.co_name
        class_name="MatchMappedAddresses"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MatchRecursiveOnly:
    statement_name = "match-recursive-only"
    xml_tag = "match_recursive_only"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MatchRecursiveOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MatchRecursiveOnly":
        function_name = sys._getframe().f_code.co_name
        class_name="MatchRecursiveOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MatchRecursiveOnly":
        function_name = sys._getframe().f_code.co_name
        class_name="MatchRecursiveOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxCacheSize:
    statement_name = "max-cache-size"
    xml_tag = "max_cache_size"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxCacheSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxCacheSize":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxCacheSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxCacheSize":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxCacheSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxCacheTtl:
    statement_name = "max-cache-ttl"
    xml_tag = "max_cache_ttl"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxCacheTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxCacheTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxCacheTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxCacheTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxCacheTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxClientsPerQuery:
    statement_name = "max-clients-per-query"
    xml_tag = "max_clients_per_query"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxClientsPerQuery"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxClientsPerQuery":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxClientsPerQuery"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxClientsPerQuery":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxClientsPerQuery"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxIxfrRatio:
    statement_name = "max-ixfr-ratio"
    xml_tag = "max_ixfr_ratio"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxIxfrRatio"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxIxfrRatio":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxIxfrRatio"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxIxfrRatio":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxIxfrRatio"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxJournalSize:
    statement_name = "max-journal-size"
    xml_tag = "max_journal_size"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxJournalSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxJournalSize":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxJournalSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxJournalSize":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxJournalSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxNcacheTtl:
    statement_name = "max-ncache-ttl"
    xml_tag = "max_ncache_ttl"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxNcacheTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxNcacheTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxNcacheTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxNcacheTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxNcacheTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxRecords:
    statement_name = "max-records"
    xml_tag = "max_records"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxRecords"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxRecords":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxRecords"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxRecords":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxRecords"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxRecursionDepth:
    statement_name = "max-recursion-depth"
    xml_tag = "max_recursion_depth"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxRecursionDepth"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxRecursionDepth":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxRecursionDepth"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxRecursionDepth":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxRecursionDepth"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxRecursionQueries:
    statement_name = "max-recursion-queries"
    xml_tag = "max_recursion_queries"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxRecursionQueries"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxRecursionQueries":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxRecursionQueries"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxRecursionQueries":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxRecursionQueries"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxRefreshTime:
    statement_name = "max-refresh-time"
    xml_tag = "max_refresh_time"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxRefreshTime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxRefreshTime":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxRefreshTime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxRefreshTime":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxRefreshTime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxRetryTime:
    statement_name = "max-retry-time"
    xml_tag = "max_retry_time"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxRetryTime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxRetryTime":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxRetryTime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxRetryTime":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxRetryTime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxRsaExponentSize:
    statement_name = "max-rsa-exponent-size"
    xml_tag = "max_rsa_exponent_size"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxRsaExponentSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxRsaExponentSize":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxRsaExponentSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxRsaExponentSize":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxRsaExponentSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxStaleTtl:
    statement_name = "max-stale-ttl"
    xml_tag = "max_stale_ttl"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxStaleTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxStaleTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxStaleTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxStaleTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxStaleTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxTableSize:
    statement_name = "max-table-size"
    xml_tag = "max_table_size"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxTableSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxTableSize":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxTableSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxTableSize":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxTableSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxTransferIdleIn:
    statement_name = "max-transfer-idle-in"
    xml_tag = "max_transfer_idle_in"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxTransferIdleIn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxTransferIdleIn":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxTransferIdleIn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxTransferIdleIn":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxTransferIdleIn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxTransferIdleOut:
    statement_name = "max-transfer-idle-out"
    xml_tag = "max_transfer_idle_out"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxTransferIdleOut"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxTransferIdleOut":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxTransferIdleOut"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxTransferIdleOut":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxTransferIdleOut"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxTransferTimeIn:
    statement_name = "max-transfer-time-in"
    xml_tag = "max_transfer_time_in"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxTransferTimeIn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxTransferTimeIn":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxTransferTimeIn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxTransferTimeIn":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxTransferTimeIn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxTransferTimeOut:
    statement_name = "max-transfer-time-out"
    xml_tag = "max_transfer_time_out"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxTransferTimeOut"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxTransferTimeOut":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxTransferTimeOut"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxTransferTimeOut":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxTransferTimeOut"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxUdpSize:
    statement_name = "max-udp-size"
    xml_tag = "max_udp_size"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxUdpSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxUdpSize":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxUdpSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxUdpSize":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxUdpSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MaxZoneTtl:
    statement_name = "max-zone-ttl"
    xml_tag = "max_zone_ttl"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MaxZoneTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MaxZoneTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxZoneTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MaxZoneTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="MaxZoneTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Memstatistics:
    statement_name = "memstatistics"
    xml_tag = "memstatistics"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Memstatistics"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Memstatistics":
        function_name = sys._getframe().f_code.co_name
        class_name="Memstatistics"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Memstatistics":
        function_name = sys._getframe().f_code.co_name
        class_name="Memstatistics"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MemstatisticsFile:
    statement_name = "memstatistics-file"
    xml_tag = "memstatistics_file"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MemstatisticsFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MemstatisticsFile":
        function_name = sys._getframe().f_code.co_name
        class_name="MemstatisticsFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MemstatisticsFile":
        function_name = sys._getframe().f_code.co_name
        class_name="MemstatisticsFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MessageCompression:
    statement_name = "message-compression"
    xml_tag = "message_compression"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MessageCompression"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MessageCompression":
        function_name = sys._getframe().f_code.co_name
        class_name="MessageCompression"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MessageCompression":
        function_name = sys._getframe().f_code.co_name
        class_name="MessageCompression"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MinCacheTtl:
    statement_name = "min-cache-ttl"
    xml_tag = "min_cache_ttl"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MinCacheTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MinCacheTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="MinCacheTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MinCacheTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="MinCacheTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MinNcacheTtl:
    statement_name = "min-ncache-ttl"
    xml_tag = "min_ncache_ttl"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MinNcacheTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MinNcacheTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="MinNcacheTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MinNcacheTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="MinNcacheTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MinRefreshTime:
    statement_name = "min-refresh-time"
    xml_tag = "min_refresh_time"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MinRefreshTime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MinRefreshTime":
        function_name = sys._getframe().f_code.co_name
        class_name="MinRefreshTime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MinRefreshTime":
        function_name = sys._getframe().f_code.co_name
        class_name="MinRefreshTime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MinRetryTime:
    statement_name = "min-retry-time"
    xml_tag = "min_retry_time"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MinRetryTime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MinRetryTime":
        function_name = sys._getframe().f_code.co_name
        class_name="MinRetryTime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MinRetryTime":
        function_name = sys._getframe().f_code.co_name
        class_name="MinRetryTime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MinTableSize:
    statement_name = "min-table-size"
    xml_tag = "min_table_size"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MinTableSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MinTableSize":
        function_name = sys._getframe().f_code.co_name
        class_name="MinTableSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MinTableSize":
        function_name = sys._getframe().f_code.co_name
        class_name="MinTableSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MinimalAny:
    statement_name = "minimal-any"
    xml_tag = "minimal_any"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MinimalAny"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MinimalAny":
        function_name = sys._getframe().f_code.co_name
        class_name="MinimalAny"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MinimalAny":
        function_name = sys._getframe().f_code.co_name
        class_name="MinimalAny"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MinimalResponses:
    statement_name = "minimal-responses"
    xml_tag = "minimal_responses"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MinimalResponses"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MinimalResponses":
        function_name = sys._getframe().f_code.co_name
        class_name="MinimalResponses"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MinimalResponses":
        function_name = sys._getframe().f_code.co_name
        class_name="MinimalResponses"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class MultiMaster:
    statement_name = "multi-master"
    xml_tag = "multi_master"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="MultiMaster"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "MultiMaster":
        function_name = sys._getframe().f_code.co_name
        class_name="MultiMaster"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "MultiMaster":
        function_name = sys._getframe().f_code.co_name
        class_name="MultiMaster"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class NewZonesDirectory:
    statement_name = "new-zones-directory"
    xml_tag = "new_zones_directory"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="NewZonesDirectory"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "NewZonesDirectory":
        function_name = sys._getframe().f_code.co_name
        class_name="NewZonesDirectory"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "NewZonesDirectory":
        function_name = sys._getframe().f_code.co_name
        class_name="NewZonesDirectory"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class NoCaseCompress:
    statement_name = "no-case-compress"
    xml_tag = "no_case_compress"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="NoCaseCompress"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "NoCaseCompress":
        function_name = sys._getframe().f_code.co_name
        class_name="NoCaseCompress"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "NoCaseCompress":
        function_name = sys._getframe().f_code.co_name
        class_name="NoCaseCompress"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class NocookieUdpSize:
    statement_name = "nocookie-udp-size"
    xml_tag = "nocookie_udp_size"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="NocookieUdpSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "NocookieUdpSize":
        function_name = sys._getframe().f_code.co_name
        class_name="NocookieUdpSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "NocookieUdpSize":
        function_name = sys._getframe().f_code.co_name
        class_name="NocookieUdpSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class NodataPerSecond:
    statement_name = "nodata-per-second"
    xml_tag = "nodata_per_second"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="NodataPerSecond"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "NodataPerSecond":
        function_name = sys._getframe().f_code.co_name
        class_name="NodataPerSecond"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "NodataPerSecond":
        function_name = sys._getframe().f_code.co_name
        class_name="NodataPerSecond"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Notify:
    statement_name = "notify"
    xml_tag = "notify"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Notify"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Notify":
        function_name = sys._getframe().f_code.co_name
        class_name="Notify"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Notify":
        function_name = sys._getframe().f_code.co_name
        class_name="Notify"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class NotifyDelay:
    statement_name = "notify-delay"
    xml_tag = "notify_delay"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="NotifyDelay"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "NotifyDelay":
        function_name = sys._getframe().f_code.co_name
        class_name="NotifyDelay"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "NotifyDelay":
        function_name = sys._getframe().f_code.co_name
        class_name="NotifyDelay"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class NotifyRate:
    statement_name = "notify-rate"
    xml_tag = "notify_rate"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="NotifyRate"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "NotifyRate":
        function_name = sys._getframe().f_code.co_name
        class_name="NotifyRate"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "NotifyRate":
        function_name = sys._getframe().f_code.co_name
        class_name="NotifyRate"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class NotifySource:
    statement_name = "notify-source"
    xml_tag = "notify_source"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="NotifySource"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "NotifySource":
        function_name = sys._getframe().f_code.co_name
        class_name="NotifySource"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "NotifySource":
        function_name = sys._getframe().f_code.co_name
        class_name="NotifySource"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class NotifySourceV6:
    statement_name = "notify-source-v6"
    xml_tag = "notify_source_v6"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="NotifySourceV6"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "NotifySourceV6":
        function_name = sys._getframe().f_code.co_name
        class_name="NotifySourceV6"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "NotifySourceV6":
        function_name = sys._getframe().f_code.co_name
        class_name="NotifySourceV6"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class NotifyToSoa:
    statement_name = "notify-to-soa"
    xml_tag = "notify_to_soa"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="NotifyToSoa"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "NotifyToSoa":
        function_name = sys._getframe().f_code.co_name
        class_name="NotifyToSoa"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "NotifyToSoa":
        function_name = sys._getframe().f_code.co_name
        class_name="NotifyToSoa"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Nsec3param:
    statement_name = "nsec3param"
    xml_tag = "nsec3param"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Nsec3param"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Nsec3param":
        function_name = sys._getframe().f_code.co_name
        class_name="Nsec3param"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Nsec3param":
        function_name = sys._getframe().f_code.co_name
        class_name="Nsec3param"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class NtaLifetime:
    statement_name = "nta-lifetime"
    xml_tag = "nta_lifetime"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="NtaLifetime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "NtaLifetime":
        function_name = sys._getframe().f_code.co_name
        class_name="NtaLifetime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "NtaLifetime":
        function_name = sys._getframe().f_code.co_name
        class_name="NtaLifetime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class NtaRecheck:
    statement_name = "nta-recheck"
    xml_tag = "nta_recheck"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="NtaRecheck"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "NtaRecheck":
        function_name = sys._getframe().f_code.co_name
        class_name="NtaRecheck"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "NtaRecheck":
        function_name = sys._getframe().f_code.co_name
        class_name="NtaRecheck"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Null:
    statement_name = "null"
    xml_tag = "null"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Null"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Null":
        function_name = sys._getframe().f_code.co_name
        class_name="Null"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Null":
        function_name = sys._getframe().f_code.co_name
        class_name="Null"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class NxdomainRedirect:
    statement_name = "nxdomain-redirect"
    xml_tag = "nxdomain_redirect"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="NxdomainRedirect"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "NxdomainRedirect":
        function_name = sys._getframe().f_code.co_name
        class_name="NxdomainRedirect"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "NxdomainRedirect":
        function_name = sys._getframe().f_code.co_name
        class_name="NxdomainRedirect"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class NxdomainsPerSecond:
    statement_name = "nxdomains-per-second"
    xml_tag = "nxdomains_per_second"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="NxdomainsPerSecond"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "NxdomainsPerSecond":
        function_name = sys._getframe().f_code.co_name
        class_name="NxdomainsPerSecond"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "NxdomainsPerSecond":
        function_name = sys._getframe().f_code.co_name
        class_name="NxdomainsPerSecond"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Padding:
    statement_name = "padding"
    xml_tag = "padding"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Padding"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Padding":
        function_name = sys._getframe().f_code.co_name
        class_name="Padding"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Padding":
        function_name = sys._getframe().f_code.co_name
        class_name="Padding"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class ParentDsTtl:
    statement_name = "parent-ds-ttl"
    xml_tag = "parent_ds_ttl"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ParentDsTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "ParentDsTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="ParentDsTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ParentDsTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="ParentDsTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class ParentPropagationDelay:
    statement_name = "parent-propagation-delay"
    xml_tag = "parent_propagation_delay"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ParentPropagationDelay"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "ParentPropagationDelay":
        function_name = sys._getframe().f_code.co_name
        class_name="ParentPropagationDelay"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ParentPropagationDelay":
        function_name = sys._getframe().f_code.co_name
        class_name="ParentPropagationDelay"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class ParentalAgents:
    statement_name = "parental-agents"
    xml_tag = "parental_agents"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ParentalAgents"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "ParentalAgents":
        function_name = sys._getframe().f_code.co_name
        class_name="ParentalAgents"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ParentalAgents":
        function_name = sys._getframe().f_code.co_name
        class_name="ParentalAgents"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class ParentalSource:
    statement_name = "parental-source"
    xml_tag = "parental_source"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ParentalSource"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "ParentalSource":
        function_name = sys._getframe().f_code.co_name
        class_name="ParentalSource"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ParentalSource":
        function_name = sys._getframe().f_code.co_name
        class_name="ParentalSource"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class ParentalSourceV6:
    statement_name = "parental-source-v6"
    xml_tag = "parental_source_v6"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ParentalSourceV6"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "ParentalSourceV6":
        function_name = sys._getframe().f_code.co_name
        class_name="ParentalSourceV6"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ParentalSourceV6":
        function_name = sys._getframe().f_code.co_name
        class_name="ParentalSourceV6"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class PidFile:
    statement_name = "pid-file"
    xml_tag = "pid_file"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="PidFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "PidFile":
        function_name = sys._getframe().f_code.co_name
        class_name="PidFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "PidFile":
        function_name = sys._getframe().f_code.co_name
        class_name="PidFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Plugin:
    statement_name = "plugin"
    xml_tag = "plugin"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Plugin"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Plugin":
        function_name = sys._getframe().f_code.co_name
        class_name="Plugin"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Plugin":
        function_name = sys._getframe().f_code.co_name
        class_name="Plugin"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Port:
    statement_name = "port"
    xml_tag = "port"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Port"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Port":
        function_name = sys._getframe().f_code.co_name
        class_name="Port"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Port":
        function_name = sys._getframe().f_code.co_name
        class_name="Port"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class PreferServerCiphers:
    statement_name = "prefer-server-ciphers"
    xml_tag = "prefer_server_ciphers"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="PreferServerCiphers"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "PreferServerCiphers":
        function_name = sys._getframe().f_code.co_name
        class_name="PreferServerCiphers"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "PreferServerCiphers":
        function_name = sys._getframe().f_code.co_name
        class_name="PreferServerCiphers"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class PreferredGlue:
    statement_name = "preferred-glue"
    xml_tag = "preferred_glue"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="PreferredGlue"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "PreferredGlue":
        function_name = sys._getframe().f_code.co_name
        class_name="PreferredGlue"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "PreferredGlue":
        function_name = sys._getframe().f_code.co_name
        class_name="PreferredGlue"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Prefetch:
    statement_name = "prefetch"
    xml_tag = "prefetch"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Prefetch"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Prefetch":
        function_name = sys._getframe().f_code.co_name
        class_name="Prefetch"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Prefetch":
        function_name = sys._getframe().f_code.co_name
        class_name="Prefetch"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Primaries:
    statement_name = "primaries"
    xml_tag = "primaries"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Primaries"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Primaries":
        function_name = sys._getframe().f_code.co_name
        class_name="Primaries"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Primaries":
        function_name = sys._getframe().f_code.co_name
        class_name="Primaries"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class PrintCategory:
    statement_name = "print-category"
    xml_tag = "print_category"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="PrintCategory"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "PrintCategory":
        function_name = sys._getframe().f_code.co_name
        class_name="PrintCategory"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "PrintCategory":
        function_name = sys._getframe().f_code.co_name
        class_name="PrintCategory"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class PrintSeverity:
    statement_name = "print-severity"
    xml_tag = "print_severity"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="PrintSeverity"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "PrintSeverity":
        function_name = sys._getframe().f_code.co_name
        class_name="PrintSeverity"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "PrintSeverity":
        function_name = sys._getframe().f_code.co_name
        class_name="PrintSeverity"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class PrintTime:
    statement_name = "print-time"
    xml_tag = "print_time"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="PrintTime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "PrintTime":
        function_name = sys._getframe().f_code.co_name
        class_name="PrintTime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "PrintTime":
        function_name = sys._getframe().f_code.co_name
        class_name="PrintTime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Protocols:
    statement_name = "protocols"
    xml_tag = "protocols"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Protocols"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Protocols":
        function_name = sys._getframe().f_code.co_name
        class_name="Protocols"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Protocols":
        function_name = sys._getframe().f_code.co_name
        class_name="Protocols"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class ProvideIxfr:
    statement_name = "provide-ixfr"
    xml_tag = "provide_ixfr"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ProvideIxfr"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "ProvideIxfr":
        function_name = sys._getframe().f_code.co_name
        class_name="ProvideIxfr"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ProvideIxfr":
        function_name = sys._getframe().f_code.co_name
        class_name="ProvideIxfr"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class PublishSafety:
    statement_name = "publish-safety"
    xml_tag = "publish_safety"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="PublishSafety"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "PublishSafety":
        function_name = sys._getframe().f_code.co_name
        class_name="PublishSafety"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "PublishSafety":
        function_name = sys._getframe().f_code.co_name
        class_name="PublishSafety"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class PurgeKeys:
    statement_name = "purge-keys"
    xml_tag = "purge_keys"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="PurgeKeys"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "PurgeKeys":
        function_name = sys._getframe().f_code.co_name
        class_name="PurgeKeys"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "PurgeKeys":
        function_name = sys._getframe().f_code.co_name
        class_name="PurgeKeys"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class QnameMinimization:
    statement_name = "qname-minimization"
    xml_tag = "qname_minimization"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="QnameMinimization"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "QnameMinimization":
        function_name = sys._getframe().f_code.co_name
        class_name="QnameMinimization"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "QnameMinimization":
        function_name = sys._getframe().f_code.co_name
        class_name="QnameMinimization"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class QpsScale:
    statement_name = "qps-scale"
    xml_tag = "qps_scale"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="QpsScale"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "QpsScale":
        function_name = sys._getframe().f_code.co_name
        class_name="QpsScale"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "QpsScale":
        function_name = sys._getframe().f_code.co_name
        class_name="QpsScale"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class QuerySource:
    statement_name = "query-source"
    xml_tag = "query_source"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="QuerySource"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "QuerySource":
        function_name = sys._getframe().f_code.co_name
        class_name="QuerySource"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "QuerySource":
        function_name = sys._getframe().f_code.co_name
        class_name="QuerySource"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class QuerySourceV6:
    statement_name = "query-source-v6"
    xml_tag = "query_source_v6"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="QuerySourceV6"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "QuerySourceV6":
        function_name = sys._getframe().f_code.co_name
        class_name="QuerySourceV6"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "QuerySourceV6":
        function_name = sys._getframe().f_code.co_name
        class_name="QuerySourceV6"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Querylog:
    statement_name = "querylog"
    xml_tag = "querylog"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Querylog"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Querylog":
        function_name = sys._getframe().f_code.co_name
        class_name="Querylog"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Querylog":
        function_name = sys._getframe().f_code.co_name
        class_name="Querylog"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class RateLimit:
    statement_name = "rate-limit"
    xml_tag = "rate_limit"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="RateLimit"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "RateLimit":
        function_name = sys._getframe().f_code.co_name
        class_name="RateLimit"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "RateLimit":
        function_name = sys._getframe().f_code.co_name
        class_name="RateLimit"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class RecursingFile:
    statement_name = "recursing-file"
    xml_tag = "recursing_file"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="RecursingFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "RecursingFile":
        function_name = sys._getframe().f_code.co_name
        class_name="RecursingFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "RecursingFile":
        function_name = sys._getframe().f_code.co_name
        class_name="RecursingFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Recursion:
    statement_name = "recursion"
    xml_tag = "recursion"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Recursion"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Recursion":
        function_name = sys._getframe().f_code.co_name
        class_name="Recursion"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Recursion":
        function_name = sys._getframe().f_code.co_name
        class_name="Recursion"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class RecursiveClients:
    statement_name = "recursive-clients"
    xml_tag = "recursive_clients"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="RecursiveClients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "RecursiveClients":
        function_name = sys._getframe().f_code.co_name
        class_name="RecursiveClients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "RecursiveClients":
        function_name = sys._getframe().f_code.co_name
        class_name="RecursiveClients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class RecursiveOnly:
    statement_name = "recursive-only"
    xml_tag = "recursive_only"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="RecursiveOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "RecursiveOnly":
        function_name = sys._getframe().f_code.co_name
        class_name="RecursiveOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "RecursiveOnly":
        function_name = sys._getframe().f_code.co_name
        class_name="RecursiveOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class ReferralsPerSecond:
    statement_name = "referrals-per-second"
    xml_tag = "referrals_per_second"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ReferralsPerSecond"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "ReferralsPerSecond":
        function_name = sys._getframe().f_code.co_name
        class_name="ReferralsPerSecond"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ReferralsPerSecond":
        function_name = sys._getframe().f_code.co_name
        class_name="ReferralsPerSecond"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class RemoteHostname:
    statement_name = "remote-hostname"
    xml_tag = "remote_hostname"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="RemoteHostname"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "RemoteHostname":
        function_name = sys._getframe().f_code.co_name
        class_name="RemoteHostname"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "RemoteHostname":
        function_name = sys._getframe().f_code.co_name
        class_name="RemoteHostname"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class RequestExpire:
    statement_name = "request-expire"
    xml_tag = "request_expire"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="RequestExpire"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "RequestExpire":
        function_name = sys._getframe().f_code.co_name
        class_name="RequestExpire"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "RequestExpire":
        function_name = sys._getframe().f_code.co_name
        class_name="RequestExpire"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class RequestIxfr:
    statement_name = "request-ixfr"
    xml_tag = "request_ixfr"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="RequestIxfr"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "RequestIxfr":
        function_name = sys._getframe().f_code.co_name
        class_name="RequestIxfr"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "RequestIxfr":
        function_name = sys._getframe().f_code.co_name
        class_name="RequestIxfr"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class RequestNsid:
    statement_name = "request-nsid"
    xml_tag = "request_nsid"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="RequestNsid"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "RequestNsid":
        function_name = sys._getframe().f_code.co_name
        class_name="RequestNsid"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "RequestNsid":
        function_name = sys._getframe().f_code.co_name
        class_name="RequestNsid"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class RequireServerCookie:
    statement_name = "require-server-cookie"
    xml_tag = "require_server_cookie"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="RequireServerCookie"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "RequireServerCookie":
        function_name = sys._getframe().f_code.co_name
        class_name="RequireServerCookie"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "RequireServerCookie":
        function_name = sys._getframe().f_code.co_name
        class_name="RequireServerCookie"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class ReservedSockets:
    statement_name = "reserved-sockets"
    xml_tag = "reserved_sockets"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ReservedSockets"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "ReservedSockets":
        function_name = sys._getframe().f_code.co_name
        class_name="ReservedSockets"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ReservedSockets":
        function_name = sys._getframe().f_code.co_name
        class_name="ReservedSockets"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class ResolverNonbackoffTries:
    statement_name = "resolver-nonbackoff-tries"
    xml_tag = "resolver_nonbackoff_tries"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ResolverNonbackoffTries"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "ResolverNonbackoffTries":
        function_name = sys._getframe().f_code.co_name
        class_name="ResolverNonbackoffTries"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ResolverNonbackoffTries":
        function_name = sys._getframe().f_code.co_name
        class_name="ResolverNonbackoffTries"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class ResolverQueryTimeout:
    statement_name = "resolver-query-timeout"
    xml_tag = "resolver_query_timeout"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ResolverQueryTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "ResolverQueryTimeout":
        function_name = sys._getframe().f_code.co_name
        class_name="ResolverQueryTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ResolverQueryTimeout":
        function_name = sys._getframe().f_code.co_name
        class_name="ResolverQueryTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class ResolverRetryInterval:
    statement_name = "resolver-retry-interval"
    xml_tag = "resolver_retry_interval"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ResolverRetryInterval"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "ResolverRetryInterval":
        function_name = sys._getframe().f_code.co_name
        class_name="ResolverRetryInterval"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ResolverRetryInterval":
        function_name = sys._getframe().f_code.co_name
        class_name="ResolverRetryInterval"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class ResponsePadding:
    statement_name = "response-padding"
    xml_tag = "response_padding"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ResponsePadding"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "ResponsePadding":
        function_name = sys._getframe().f_code.co_name
        class_name="ResponsePadding"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ResponsePadding":
        function_name = sys._getframe().f_code.co_name
        class_name="ResponsePadding"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class ResponsePolicy:
    statement_name = "response-policy"
    xml_tag = "response_policy"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ResponsePolicy"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "ResponsePolicy":
        function_name = sys._getframe().f_code.co_name
        class_name="ResponsePolicy"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ResponsePolicy":
        function_name = sys._getframe().f_code.co_name
        class_name="ResponsePolicy"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class ResponsesPerSecond:
    statement_name = "responses-per-second"
    xml_tag = "responses_per_second"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ResponsesPerSecond"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "ResponsesPerSecond":
        function_name = sys._getframe().f_code.co_name
        class_name="ResponsesPerSecond"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ResponsesPerSecond":
        function_name = sys._getframe().f_code.co_name
        class_name="ResponsesPerSecond"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class RetireSafety:
    statement_name = "retire-safety"
    xml_tag = "retire_safety"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="RetireSafety"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "RetireSafety":
        function_name = sys._getframe().f_code.co_name
        class_name="RetireSafety"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "RetireSafety":
        function_name = sys._getframe().f_code.co_name
        class_name="RetireSafety"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Reuseport:
    statement_name = "reuseport"
    xml_tag = "reuseport"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Reuseport"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Reuseport":
        function_name = sys._getframe().f_code.co_name
        class_name="Reuseport"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Reuseport":
        function_name = sys._getframe().f_code.co_name
        class_name="Reuseport"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class RootDelegationOnly:
    statement_name = "root-delegation-only"
    xml_tag = "root_delegation_only"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="RootDelegationOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "RootDelegationOnly":
        function_name = sys._getframe().f_code.co_name
        class_name="RootDelegationOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "RootDelegationOnly":
        function_name = sys._getframe().f_code.co_name
        class_name="RootDelegationOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class RootKeySentinel:
    statement_name = "root-key-sentinel"
    xml_tag = "root_key_sentinel"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="RootKeySentinel"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "RootKeySentinel":
        function_name = sys._getframe().f_code.co_name
        class_name="RootKeySentinel"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "RootKeySentinel":
        function_name = sys._getframe().f_code.co_name
        class_name="RootKeySentinel"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class RrsetOrder:
    statement_name = "rrset-order"
    xml_tag = "rrset_order"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="RrsetOrder"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "RrsetOrder":
        function_name = sys._getframe().f_code.co_name
        class_name="RrsetOrder"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "RrsetOrder":
        function_name = sys._getframe().f_code.co_name
        class_name="RrsetOrder"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class Search:
    statement_name = "search"
    xml_tag = "search"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Search"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Search":
        function_name = sys._getframe().f_code.co_name
        class_name="Search"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Search":
        function_name = sys._getframe().f_code.co_name
        class_name="Search"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Secret:
    statement_name = "secret"
    xml_tag = "secret"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Secret"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Secret":
        function_name = sys._getframe().f_code.co_name
        class_name="Secret"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Secret":
        function_name = sys._getframe().f_code.co_name
        class_name="Secret"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class SecrootsFile:
    statement_name = "secroots-file"
    xml_tag = "secroots_file"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="SecrootsFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "SecrootsFile":
        function_name = sys._getframe().f_code.co_name
        class_name="SecrootsFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "SecrootsFile":
        function_name = sys._getframe().f_code.co_name
        class_name="SecrootsFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class SendCookie:
    statement_name = "send-cookie"
    xml_tag = "send_cookie"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="SendCookie"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "SendCookie":
        function_name = sys._getframe().f_code.co_name
        class_name="SendCookie"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "SendCookie":
        function_name = sys._getframe().f_code.co_name
        class_name="SendCookie"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class SerialQueryRate:
    statement_name = "serial-query-rate"
    xml_tag = "serial_query_rate"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="SerialQueryRate"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "SerialQueryRate":
        function_name = sys._getframe().f_code.co_name
        class_name="SerialQueryRate"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "SerialQueryRate":
        function_name = sys._getframe().f_code.co_name
        class_name="SerialQueryRate"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class SerialUpdateMethod:
    statement_name = "serial-update-method"
    xml_tag = "serial_update_method"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="SerialUpdateMethod"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "SerialUpdateMethod":
        function_name = sys._getframe().f_code.co_name
        class_name="SerialUpdateMethod"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "SerialUpdateMethod":
        function_name = sys._getframe().f_code.co_name
        class_name="SerialUpdateMethod"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Server:
    statement_name = "server"
    ALLOWED_STATEMENTS = [
        "bogus",
        "edns",
        "edns-udp-size",
        "edns-version",
        "keys",
        "max-udp-size",
        "notify-source",
        "notify-source-v6",
        "padding",
        "provide-ixfr",
        "query-source",
        "query-source-v6",
        "request-expire",
        "request-ixfr",
        "request-nsid",
        "send-cookie",
        "tcp-keepalive",
        "tcp-only",
        "transfer-format",
        "transfer-source",
        "transfer-source-v6",
        "transfers",
    ]

    xml_tag = "server"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Server"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Server":
        function_name = sys._getframe().f_code.co_name
        class_name="Server"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Server":
        function_name = sys._getframe().f_code.co_name
        class_name="Server"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class ServerAddresses:
    statement_name = "server-addresses"
    xml_tag = "server_addresses"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ServerAddresses"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "ServerAddresses":
        function_name = sys._getframe().f_code.co_name
        class_name="ServerAddresses"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ServerAddresses":
        function_name = sys._getframe().f_code.co_name
        class_name="ServerAddresses"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class ServerId:
    statement_name = "server-id"
    xml_tag = "server_id"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ServerId"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "ServerId":
        function_name = sys._getframe().f_code.co_name
        class_name="ServerId"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ServerId":
        function_name = sys._getframe().f_code.co_name
        class_name="ServerId"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class ServerNames:
    statement_name = "server-names"
    xml_tag = "server_names"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ServerNames"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "ServerNames":
        function_name = sys._getframe().f_code.co_name
        class_name="ServerNames"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ServerNames":
        function_name = sys._getframe().f_code.co_name
        class_name="ServerNames"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class ServfailTtl:
    statement_name = "servfail-ttl"
    xml_tag = "servfail_ttl"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ServfailTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "ServfailTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="ServfailTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ServfailTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="ServfailTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class SessionKeyalg:
    statement_name = "session-keyalg"
    xml_tag = "session_keyalg"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="SessionKeyalg"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "SessionKeyalg":
        function_name = sys._getframe().f_code.co_name
        class_name="SessionKeyalg"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "SessionKeyalg":
        function_name = sys._getframe().f_code.co_name
        class_name="SessionKeyalg"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class SessionKeyfile:
    statement_name = "session-keyfile"
    xml_tag = "session_keyfile"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="SessionKeyfile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "SessionKeyfile":
        function_name = sys._getframe().f_code.co_name
        class_name="SessionKeyfile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "SessionKeyfile":
        function_name = sys._getframe().f_code.co_name
        class_name="SessionKeyfile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class SessionKeyname:
    statement_name = "session-keyname"
    xml_tag = "session_keyname"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="SessionKeyname"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "SessionKeyname":
        function_name = sys._getframe().f_code.co_name
        class_name="SessionKeyname"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "SessionKeyname":
        function_name = sys._getframe().f_code.co_name
        class_name="SessionKeyname"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class SessionTickets:
    statement_name = "session-tickets"
    xml_tag = "session_tickets"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="SessionTickets"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "SessionTickets":
        function_name = sys._getframe().f_code.co_name
        class_name="SessionTickets"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "SessionTickets":
        function_name = sys._getframe().f_code.co_name
        class_name="SessionTickets"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Severity:
    statement_name = "severity"
    xml_tag = "severity"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Severity"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Severity":
        function_name = sys._getframe().f_code.co_name
        class_name="Severity"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Severity":
        function_name = sys._getframe().f_code.co_name
        class_name="Severity"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class SigSigningNodes:
    statement_name = "sig-signing-nodes"
    xml_tag = "sig_signing_nodes"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="SigSigningNodes"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "SigSigningNodes":
        function_name = sys._getframe().f_code.co_name
        class_name="SigSigningNodes"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "SigSigningNodes":
        function_name = sys._getframe().f_code.co_name
        class_name="SigSigningNodes"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class SigSigningSignatures:
    statement_name = "sig-signing-signatures"
    xml_tag = "sig_signing_signatures"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="SigSigningSignatures"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "SigSigningSignatures":
        function_name = sys._getframe().f_code.co_name
        class_name="SigSigningSignatures"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "SigSigningSignatures":
        function_name = sys._getframe().f_code.co_name
        class_name="SigSigningSignatures"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class SigSigningType:
    statement_name = "sig-signing-type"
    xml_tag = "sig_signing_type"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="SigSigningType"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "SigSigningType":
        function_name = sys._getframe().f_code.co_name
        class_name="SigSigningType"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "SigSigningType":
        function_name = sys._getframe().f_code.co_name
        class_name="SigSigningType"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class SigValidityInterval:
    statement_name = "sig-validity-interval"
    xml_tag = "sig_validity_interval"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="SigValidityInterval"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "SigValidityInterval":
        function_name = sys._getframe().f_code.co_name
        class_name="SigValidityInterval"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "SigValidityInterval":
        function_name = sys._getframe().f_code.co_name
        class_name="SigValidityInterval"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class SignaturesRefresh:
    statement_name = "signatures-refresh"
    xml_tag = "signatures_refresh"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="SignaturesRefresh"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "SignaturesRefresh":
        function_name = sys._getframe().f_code.co_name
        class_name="SignaturesRefresh"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "SignaturesRefresh":
        function_name = sys._getframe().f_code.co_name
        class_name="SignaturesRefresh"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class SignaturesValidity:
    statement_name = "signatures-validity"
    xml_tag = "signatures_validity"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="SignaturesValidity"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "SignaturesValidity":
        function_name = sys._getframe().f_code.co_name
        class_name="SignaturesValidity"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "SignaturesValidity":
        function_name = sys._getframe().f_code.co_name
        class_name="SignaturesValidity"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class SignaturesValidityDnskey:
    statement_name = "signatures-validity-dnskey"
    xml_tag = "signatures_validity_dnskey"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="SignaturesValidityDnskey"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "SignaturesValidityDnskey":
        function_name = sys._getframe().f_code.co_name
        class_name="SignaturesValidityDnskey"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "SignaturesValidityDnskey":
        function_name = sys._getframe().f_code.co_name
        class_name="SignaturesValidityDnskey"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Slip:
    statement_name = "slip"
    xml_tag = "slip"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Slip"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Slip":
        function_name = sys._getframe().f_code.co_name
        class_name="Slip"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Slip":
        function_name = sys._getframe().f_code.co_name
        class_name="Slip"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Sortlist:
    statement_name = "sortlist"
    xml_tag = "sortlist"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Sortlist"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Sortlist":
        function_name = sys._getframe().f_code.co_name
        class_name="Sortlist"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Sortlist":
        function_name = sys._getframe().f_code.co_name
        class_name="Sortlist"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class Stacksize:
    statement_name = "stacksize"
    xml_tag = "stacksize"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Stacksize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Stacksize":
        function_name = sys._getframe().f_code.co_name
        class_name="Stacksize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Stacksize":
        function_name = sys._getframe().f_code.co_name
        class_name="Stacksize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class StaleAnswerClientTimeout:
    statement_name = "stale-answer-client-timeout"
    xml_tag = "stale_answer_client_timeout"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="StaleAnswerClientTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "StaleAnswerClientTimeout":
        function_name = sys._getframe().f_code.co_name
        class_name="StaleAnswerClientTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "StaleAnswerClientTimeout":
        function_name = sys._getframe().f_code.co_name
        class_name="StaleAnswerClientTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class StaleAnswerEnable:
    statement_name = "stale-answer-enable"
    xml_tag = "stale_answer_enable"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="StaleAnswerEnable"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "StaleAnswerEnable":
        function_name = sys._getframe().f_code.co_name
        class_name="StaleAnswerEnable"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "StaleAnswerEnable":
        function_name = sys._getframe().f_code.co_name
        class_name="StaleAnswerEnable"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class StaleAnswerTtl:
    statement_name = "stale-answer-ttl"
    xml_tag = "stale_answer_ttl"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="StaleAnswerTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "StaleAnswerTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="StaleAnswerTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "StaleAnswerTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="StaleAnswerTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class StaleCacheEnable:
    statement_name = "stale-cache-enable"
    xml_tag = "stale_cache_enable"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="StaleCacheEnable"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "StaleCacheEnable":
        function_name = sys._getframe().f_code.co_name
        class_name="StaleCacheEnable"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "StaleCacheEnable":
        function_name = sys._getframe().f_code.co_name
        class_name="StaleCacheEnable"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class StaleRefreshTime:
    statement_name = "stale-refresh-time"
    xml_tag = "stale_refresh_time"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="StaleRefreshTime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "StaleRefreshTime":
        function_name = sys._getframe().f_code.co_name
        class_name="StaleRefreshTime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "StaleRefreshTime":
        function_name = sys._getframe().f_code.co_name
        class_name="StaleRefreshTime"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class StartupNotifyRate:
    statement_name = "startup-notify-rate"
    xml_tag = "startup_notify_rate"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="StartupNotifyRate"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "StartupNotifyRate":
        function_name = sys._getframe().f_code.co_name
        class_name="StartupNotifyRate"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "StartupNotifyRate":
        function_name = sys._getframe().f_code.co_name
        class_name="StartupNotifyRate"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class StatisticsChannels:
    statement_name = "statistics-channels"
    ALLOWED_STATEMENTS = [
        "inet",
    ]

    xml_tag = "statistics_channels"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="StatisticsChannels"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "StatisticsChannels":
        function_name = sys._getframe().f_code.co_name
        class_name="StatisticsChannels"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "StatisticsChannels":
        function_name = sys._getframe().f_code.co_name
        class_name="StatisticsChannels"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class StatisticsFile:
    statement_name = "statistics-file"
    xml_tag = "statistics_file"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="StatisticsFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "StatisticsFile":
        function_name = sys._getframe().f_code.co_name
        class_name="StatisticsFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "StatisticsFile":
        function_name = sys._getframe().f_code.co_name
        class_name="StatisticsFile"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Stderr:
    statement_name = "stderr"
    xml_tag = "stderr"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Stderr"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Stderr":
        function_name = sys._getframe().f_code.co_name
        class_name="Stderr"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Stderr":
        function_name = sys._getframe().f_code.co_name
        class_name="Stderr"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class StreamsPerConnection:
    statement_name = "streams-per-connection"
    xml_tag = "streams_per_connection"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="StreamsPerConnection"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "StreamsPerConnection":
        function_name = sys._getframe().f_code.co_name
        class_name="StreamsPerConnection"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "StreamsPerConnection":
        function_name = sys._getframe().f_code.co_name
        class_name="StreamsPerConnection"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Suffix:
    statement_name = "suffix"
    xml_tag = "suffix"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Suffix"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Suffix":
        function_name = sys._getframe().f_code.co_name
        class_name="Suffix"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Suffix":
        function_name = sys._getframe().f_code.co_name
        class_name="Suffix"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class SynthFromDnssec:
    statement_name = "synth-from-dnssec"
    xml_tag = "synth_from_dnssec"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="SynthFromDnssec"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "SynthFromDnssec":
        function_name = sys._getframe().f_code.co_name
        class_name="SynthFromDnssec"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "SynthFromDnssec":
        function_name = sys._getframe().f_code.co_name
        class_name="SynthFromDnssec"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Syslog:
    statement_name = "syslog"
    xml_tag = "syslog"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Syslog"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Syslog":
        function_name = sys._getframe().f_code.co_name
        class_name="Syslog"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Syslog":
        function_name = sys._getframe().f_code.co_name
        class_name="Syslog"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TcpAdvertisedTimeout:
    statement_name = "tcp-advertised-timeout"
    xml_tag = "tcp_advertised_timeout"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TcpAdvertisedTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TcpAdvertisedTimeout":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpAdvertisedTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TcpAdvertisedTimeout":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpAdvertisedTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TcpClients:
    statement_name = "tcp-clients"
    xml_tag = "tcp_clients"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TcpClients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TcpClients":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpClients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TcpClients":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpClients"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TcpIdleTimeout:
    statement_name = "tcp-idle-timeout"
    xml_tag = "tcp_idle_timeout"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TcpIdleTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TcpIdleTimeout":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpIdleTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TcpIdleTimeout":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpIdleTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TcpInitialTimeout:
    statement_name = "tcp-initial-timeout"
    xml_tag = "tcp_initial_timeout"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TcpInitialTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TcpInitialTimeout":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpInitialTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TcpInitialTimeout":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpInitialTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TcpKeepalive:
    statement_name = "tcp-keepalive"
    xml_tag = "tcp_keepalive"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TcpKeepalive"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TcpKeepalive":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpKeepalive"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TcpKeepalive":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpKeepalive"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TcpKeepaliveTimeout:
    statement_name = "tcp-keepalive-timeout"
    xml_tag = "tcp_keepalive_timeout"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TcpKeepaliveTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TcpKeepaliveTimeout":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpKeepaliveTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TcpKeepaliveTimeout":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpKeepaliveTimeout"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TcpListenQueue:
    statement_name = "tcp-listen-queue"
    xml_tag = "tcp_listen_queue"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TcpListenQueue"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "TcpListenQueue":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpListenQueue"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TcpListenQueue":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpListenQueue"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class TcpOnly:
    statement_name = "tcp-only"
    xml_tag = "tcp_only"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TcpOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TcpOnly":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TcpOnly":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TcpReceiveBuffer:
    statement_name = "tcp-receive-buffer"
    xml_tag = "tcp_receive_buffer"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TcpReceiveBuffer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TcpReceiveBuffer":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpReceiveBuffer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TcpReceiveBuffer":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpReceiveBuffer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TcpSendBuffer:
    statement_name = "tcp-send-buffer"
    xml_tag = "tcp_send_buffer"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TcpSendBuffer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TcpSendBuffer":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpSendBuffer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TcpSendBuffer":
        function_name = sys._getframe().f_code.co_name
        class_name="TcpSendBuffer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TkeyDhkey:
    statement_name = "tkey-dhkey"
    xml_tag = "tkey_dhkey"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TkeyDhkey"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TkeyDhkey":
        function_name = sys._getframe().f_code.co_name
        class_name="TkeyDhkey"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TkeyDhkey":
        function_name = sys._getframe().f_code.co_name
        class_name="TkeyDhkey"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TkeyDomain:
    statement_name = "tkey-domain"
    xml_tag = "tkey_domain"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TkeyDomain"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TkeyDomain":
        function_name = sys._getframe().f_code.co_name
        class_name="TkeyDomain"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TkeyDomain":
        function_name = sys._getframe().f_code.co_name
        class_name="TkeyDomain"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TkeyGssapiCredential:
    statement_name = "tkey-gssapi-credential"
    xml_tag = "tkey_gssapi_credential"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TkeyGssapiCredential"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TkeyGssapiCredential":
        function_name = sys._getframe().f_code.co_name
        class_name="TkeyGssapiCredential"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TkeyGssapiCredential":
        function_name = sys._getframe().f_code.co_name
        class_name="TkeyGssapiCredential"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TkeyGssapiKeytab:
    statement_name = "tkey-gssapi-keytab"
    xml_tag = "tkey_gssapi_keytab"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TkeyGssapiKeytab"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TkeyGssapiKeytab":
        function_name = sys._getframe().f_code.co_name
        class_name="TkeyGssapiKeytab"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TkeyGssapiKeytab":
        function_name = sys._getframe().f_code.co_name
        class_name="TkeyGssapiKeytab"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Tls:
    statement_name = "tls"
    ALLOWED_STATEMENTS = [
        "ca-file",
        "cert-file",
        "ciphers",
        "dhparam-file",
        "key-file",
        "prefer-server-ciphers",
        "protocols",
        "remote-hostname",
        "session-tickets",
    ]

    xml_tag = "tls"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Tls"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Tls":
        function_name = sys._getframe().f_code.co_name
        class_name="Tls"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Tls":
        function_name = sys._getframe().f_code.co_name
        class_name="Tls"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class TlsPort:
    statement_name = "tls-port"
    xml_tag = "tls_port"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TlsPort"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TlsPort":
        function_name = sys._getframe().f_code.co_name
        class_name="TlsPort"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TlsPort":
        function_name = sys._getframe().f_code.co_name
        class_name="TlsPort"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TransferFormat:
    statement_name = "transfer-format"
    xml_tag = "transfer_format"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TransferFormat"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TransferFormat":
        function_name = sys._getframe().f_code.co_name
        class_name="TransferFormat"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TransferFormat":
        function_name = sys._getframe().f_code.co_name
        class_name="TransferFormat"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TransferMessageSize:
    statement_name = "transfer-message-size"
    xml_tag = "transfer_message_size"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TransferMessageSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TransferMessageSize":
        function_name = sys._getframe().f_code.co_name
        class_name="TransferMessageSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TransferMessageSize":
        function_name = sys._getframe().f_code.co_name
        class_name="TransferMessageSize"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TransferSource:
    statement_name = "transfer-source"
    xml_tag = "transfer_source"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TransferSource"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TransferSource":
        function_name = sys._getframe().f_code.co_name
        class_name="TransferSource"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TransferSource":
        function_name = sys._getframe().f_code.co_name
        class_name="TransferSource"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TransferSourceV6:
    statement_name = "transfer-source-v6"
    xml_tag = "transfer_source_v6"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TransferSourceV6"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TransferSourceV6":
        function_name = sys._getframe().f_code.co_name
        class_name="TransferSourceV6"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TransferSourceV6":
        function_name = sys._getframe().f_code.co_name
        class_name="TransferSourceV6"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Transfers:
    statement_name = "transfers"
    xml_tag = "transfers"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Transfers"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Transfers":
        function_name = sys._getframe().f_code.co_name
        class_name="Transfers"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Transfers":
        function_name = sys._getframe().f_code.co_name
        class_name="Transfers"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TransfersIn:
    statement_name = "transfers-in"
    xml_tag = "transfers_in"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TransfersIn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TransfersIn":
        function_name = sys._getframe().f_code.co_name
        class_name="TransfersIn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TransfersIn":
        function_name = sys._getframe().f_code.co_name
        class_name="TransfersIn"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TransfersOut:
    statement_name = "transfers-out"
    xml_tag = "transfers_out"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TransfersOut"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TransfersOut":
        function_name = sys._getframe().f_code.co_name
        class_name="TransfersOut"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TransfersOut":
        function_name = sys._getframe().f_code.co_name
        class_name="TransfersOut"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TransfersPerNs:
    statement_name = "transfers-per-ns"
    xml_tag = "transfers_per_ns"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TransfersPerNs"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TransfersPerNs":
        function_name = sys._getframe().f_code.co_name
        class_name="TransfersPerNs"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TransfersPerNs":
        function_name = sys._getframe().f_code.co_name
        class_name="TransfersPerNs"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TrustAnchorTelemetry:
    statement_name = "trust-anchor-telemetry"
    xml_tag = "trust_anchor_telemetry"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TrustAnchorTelemetry"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TrustAnchorTelemetry":
        function_name = sys._getframe().f_code.co_name
        class_name="TrustAnchorTelemetry"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TrustAnchorTelemetry":
        function_name = sys._getframe().f_code.co_name
        class_name="TrustAnchorTelemetry"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TrustAnchors:
    statement_name = "trust-anchors"
    xml_tag = "trust_anchors"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TrustAnchors"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "TrustAnchors":
        function_name = sys._getframe().f_code.co_name
        class_name="TrustAnchors"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TrustAnchors":
        function_name = sys._getframe().f_code.co_name
        class_name="TrustAnchors"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class TrustedKeys:
    statement_name = "trusted-keys"
    xml_tag = "trusted_keys"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TrustedKeys"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "TrustedKeys":
        function_name = sys._getframe().f_code.co_name
        class_name="TrustedKeys"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TrustedKeys":
        function_name = sys._getframe().f_code.co_name
        class_name="TrustedKeys"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class TryTcpRefresh:
    statement_name = "try-tcp-refresh"
    xml_tag = "try_tcp_refresh"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TryTcpRefresh"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TryTcpRefresh":
        function_name = sys._getframe().f_code.co_name
        class_name="TryTcpRefresh"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TryTcpRefresh":
        function_name = sys._getframe().f_code.co_name
        class_name="TryTcpRefresh"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Type:
    statement_name = "type"
    xml_tag = "type"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Type"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Type":
        function_name = sys._getframe().f_code.co_name
        class_name="Type"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Type":
        function_name = sys._getframe().f_code.co_name
        class_name="Type"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class TypeDelegationOnly:
    statement_name = "type delegation-only"
    xml_tag = "type delegation_only"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TypeDelegationOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TypeDelegationOnly":
        function_name = sys._getframe().f_code.co_name
        class_name="TypeDelegationOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TypeDelegationOnly":
        function_name = sys._getframe().f_code.co_name
        class_name="TypeDelegationOnly"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TypeForward:
    statement_name = "type forward"
    xml_tag = "type forward"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TypeForward"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TypeForward":
        function_name = sys._getframe().f_code.co_name
        class_name="TypeForward"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TypeForward":
        function_name = sys._getframe().f_code.co_name
        class_name="TypeForward"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TypeHint:
    statement_name = "type hint"
    xml_tag = "type hint"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TypeHint"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TypeHint":
        function_name = sys._getframe().f_code.co_name
        class_name="TypeHint"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TypeHint":
        function_name = sys._getframe().f_code.co_name
        class_name="TypeHint"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TypeMirror:
    statement_name = "type mirror"
    xml_tag = "type mirror"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TypeMirror"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TypeMirror":
        function_name = sys._getframe().f_code.co_name
        class_name="TypeMirror"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TypeMirror":
        function_name = sys._getframe().f_code.co_name
        class_name="TypeMirror"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TypePrimary:
    statement_name = "type primary"
    xml_tag = "type primary"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TypePrimary"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TypePrimary":
        function_name = sys._getframe().f_code.co_name
        class_name="TypePrimary"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TypePrimary":
        function_name = sys._getframe().f_code.co_name
        class_name="TypePrimary"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TypeRedirect:
    statement_name = "type redirect"
    xml_tag = "type redirect"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TypeRedirect"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TypeRedirect":
        function_name = sys._getframe().f_code.co_name
        class_name="TypeRedirect"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TypeRedirect":
        function_name = sys._getframe().f_code.co_name
        class_name="TypeRedirect"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TypeSecondary:
    statement_name = "type secondary"
    xml_tag = "type secondary"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TypeSecondary"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TypeSecondary":
        function_name = sys._getframe().f_code.co_name
        class_name="TypeSecondary"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TypeSecondary":
        function_name = sys._getframe().f_code.co_name
        class_name="TypeSecondary"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TypeStaticStub:
    statement_name = "type static-stub"
    xml_tag = "type static_stub"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TypeStaticStub"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TypeStaticStub":
        function_name = sys._getframe().f_code.co_name
        class_name="TypeStaticStub"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TypeStaticStub":
        function_name = sys._getframe().f_code.co_name
        class_name="TypeStaticStub"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class TypeStub:
    statement_name = "type stub"
    xml_tag = "type stub"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="TypeStub"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "TypeStub":
        function_name = sys._getframe().f_code.co_name
        class_name="TypeStub"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "TypeStub":
        function_name = sys._getframe().f_code.co_name
        class_name="TypeStub"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class UdpReceiveBuffer:
    statement_name = "udp-receive-buffer"
    xml_tag = "udp_receive_buffer"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="UdpReceiveBuffer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "UdpReceiveBuffer":
        function_name = sys._getframe().f_code.co_name
        class_name="UdpReceiveBuffer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "UdpReceiveBuffer":
        function_name = sys._getframe().f_code.co_name
        class_name="UdpReceiveBuffer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class UdpSendBuffer:
    statement_name = "udp-send-buffer"
    xml_tag = "udp_send_buffer"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="UdpSendBuffer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "UdpSendBuffer":
        function_name = sys._getframe().f_code.co_name
        class_name="UdpSendBuffer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "UdpSendBuffer":
        function_name = sys._getframe().f_code.co_name
        class_name="UdpSendBuffer"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class Unix:
    statement_name = "unix"
    xml_tag = "unix"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Unix"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "Unix":
        function_name = sys._getframe().f_code.co_name
        class_name="Unix"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Unix":
        function_name = sys._getframe().f_code.co_name
        class_name="Unix"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class UpdateCheckKsk:
    statement_name = "update-check-ksk"
    xml_tag = "update_check_ksk"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="UpdateCheckKsk"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "UpdateCheckKsk":
        function_name = sys._getframe().f_code.co_name
        class_name="UpdateCheckKsk"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "UpdateCheckKsk":
        function_name = sys._getframe().f_code.co_name
        class_name="UpdateCheckKsk"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class UpdatePolicy:
    statement_name = "update-policy"
    xml_tag = "update_policy"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="UpdatePolicy"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "UpdatePolicy":
        function_name = sys._getframe().f_code.co_name
        class_name="UpdatePolicy"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "UpdatePolicy":
        function_name = sys._getframe().f_code.co_name
        class_name="UpdatePolicy"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class UpdateQuota:
    statement_name = "update-quota"
    xml_tag = "update_quota"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="UpdateQuota"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "UpdateQuota":
        function_name = sys._getframe().f_code.co_name
        class_name="UpdateQuota"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "UpdateQuota":
        function_name = sys._getframe().f_code.co_name
        class_name="UpdateQuota"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class UseAltTransferSource:
    statement_name = "use-alt-transfer-source"
    xml_tag = "use_alt_transfer_source"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="UseAltTransferSource"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "UseAltTransferSource":
        function_name = sys._getframe().f_code.co_name
        class_name="UseAltTransferSource"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "UseAltTransferSource":
        function_name = sys._getframe().f_code.co_name
        class_name="UseAltTransferSource"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class UseV4UdpPorts:
    statement_name = "use-v4-udp-ports"
    xml_tag = "use_v4_udp_ports"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="UseV4UdpPorts"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "UseV4UdpPorts":
        function_name = sys._getframe().f_code.co_name
        class_name="UseV4UdpPorts"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "UseV4UdpPorts":
        function_name = sys._getframe().f_code.co_name
        class_name="UseV4UdpPorts"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class UseV6UdpPorts:
    statement_name = "use-v6-udp-ports"
    xml_tag = "use_v6_udp_ports"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="UseV6UdpPorts"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "UseV6UdpPorts":
        function_name = sys._getframe().f_code.co_name
        class_name="UseV6UdpPorts"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "UseV6UdpPorts":
        function_name = sys._getframe().f_code.co_name
        class_name="UseV6UdpPorts"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class V6Bias:
    statement_name = "v6-bias"
    xml_tag = "v6_bias"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="V6Bias"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "V6Bias":
        function_name = sys._getframe().f_code.co_name
        class_name="V6Bias"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "V6Bias":
        function_name = sys._getframe().f_code.co_name
        class_name="V6Bias"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class ValidateExcept:
    statement_name = "validate-except"
    xml_tag = "validate_except"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ValidateExcept"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "ValidateExcept":
        function_name = sys._getframe().f_code.co_name
        class_name="ValidateExcept"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ValidateExcept":
        function_name = sys._getframe().f_code.co_name
        class_name="ValidateExcept"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class Version:
    statement_name = "version"
    xml_tag = "version"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Version"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Version":
        function_name = sys._getframe().f_code.co_name
        class_name="Version"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Version":
        function_name = sys._getframe().f_code.co_name
        class_name="Version"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class View:
    statement_name = "view"
    ALLOWED_STATEMENTS = [
        "allow-new-zones",
        "allow-notify",
        "allow-query",
        "allow-query-cache",
        "allow-query-cache-on",
        "allow-query-on",
        "allow-recursion",
        "allow-recursion-on",
        "allow-transfer",
        "allow-update",
        "allow-update-forwarding",
        "also-notify",
        "alt-transfer-source",
        "alt-transfer-source-v6",
        "attach-cache",
        "auth-nxdomain",
        "auto-dnssec",
        "check-dup-records",
        "check-integrity",
        "check-mx",
        "check-mx-cname",
        "check-names",
        "check-sibling",
        "check-spf",
        "check-srv-cname",
        "check-wildcard",
        "clients-per-query",
        "deny-answer-addresses",
        "deny-answer-aliases",
        "dialup",
        "disable-algorithms",
        "disable-ds-digests",
        "disable-empty-zone",
        "dns64",
        "dns64-contact",
        "dnskey-sig-validity",
        "dnsrps-enable",
        "dnsrps-options",
        "dnssec-accept-expired",
        "dnssec-dnskey-kskonly",
        "dnssec-loadkeys-interval",
        "dnssec-must-be-secure",
        "dnssec-policy",
        "dnssec-secure-to-insecure",
        "dnssec-update-mode",
        "dnssec-validation",
        "dnstap",
        "dual-stack-servers",
        "edns-udp-size",
        "empty-contact",
        "empty-server",
        "empty-zones-enable",
        "fetch-quota-params",
        "fetches-per-server",
        "fetches-per-zone",
        "forward",
        "forwarders",
        "glue-cache",
        "ipv4only-contact",
        "ipv4only-enable",
        "ipv4only-server",
        "ixfr-from-differences",
        "key",
        "key-directory",
        "lame-ttl",
        "lmdb-mapsize",
        "managed-keys",
        "masterfile-format",
        "masterfile-style",
        "match-clients",
        "match-destinations",
        "match-recursive-only",
        "max-cache-size",
        "max-cache-ttl",
        "max-clients-per-query",
        "max-ixfr-ratio",
        "max-journal-size",
        "max-ncache-ttl",
        "max-records",
        "max-recursion-depth",
        "max-recursion-queries",
        "max-refresh-time",
        "max-retry-time",
        "max-stale-ttl",
        "max-transfer-idle-in",
        "max-transfer-idle-out",
        "max-transfer-time-in",
        "max-transfer-time-out",
        "max-udp-size",
        "max-zone-ttl",
        "message-compression",
        "min-cache-ttl",
        "min-ncache-ttl",
        "min-refresh-time",
        "min-retry-time",
        "minimal-any",
        "minimal-responses",
        "multi-master",
        "new-zones-directory",
        "no-case-compress",
        "nocookie-udp-size",
        "notify",
        "notify-delay",
        "notify-source",
        "notify-source-v6",
        "notify-to-soa",
        "nta-lifetime",
        "nta-recheck",
        "nxdomain-redirect",
        "parental-source",
        "parental-source-v6",
        "preferred-glue",
        "prefetch",
        "provide-ixfr",
        "qname-minimization",
        "query-source",
        "query-source-v6",
        "rate-limit",
        "recursion",
        "request-expire",
        "request-ixfr",
        "request-nsid",
        "require-server-cookie",
        "resolver-nonbackoff-tries",
        "resolver-query-timeout",
        "resolver-retry-interval",
        "response-padding",
        "response-policy",
        "root-delegation-only",
        "root-key-sentinel",
        "rrset-order",
        "send-cookie",
        "serial-update-method",
        "server",
        "servfail-ttl",
        "sig-signing-nodes",
        "sig-signing-signatures",
        "sig-signing-type",
        "sig-validity-interval",
        "sortlist",
        "stale-answer-client-timeout",
        "stale-answer-enable",
        "stale-answer-ttl",
        "stale-cache-enable",
        "stale-refresh-time",
        "synth-from-dnssec",
        "transfer-format",
        "transfer-source",
        "transfer-source-v6",
        "trust-anchor-telemetry",
        "trust-anchors",
        "trusted-keys",
        "try-tcp-refresh",
        "update-check-ksk",
        "use-alt-transfer-source",
        "v6-bias",
        "validate-except",
        "zero-no-soa-ttl",
        "zero-no-soa-ttl-cache",
        "zone",
        "zone-statistics",
    ]

    xml_tag = "view"
    def __init__(self, elements: Optional[List[str]] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = elements or []

        logger.debug("Leaving function "+str(function_name))
    def add(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements.append(element)

        logger.debug("Leaving function "+str(function_name))
    def remove(self, element: str) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.elements = [item for item in self.elements if item != element]

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="View"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"elements": list(self.elements)}

    @classmethod
    def from_dict(cls, data: dict) -> "View":
        function_name = sys._getframe().f_code.co_name
        class_name="View"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, list):
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=list(data))
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=list(data.get("elements", [])))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        for item in self.elements:
            entry = ET.SubElement(element, "value")
            entry.text = item
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "View":
        function_name = sys._getframe().f_code.co_name
        class_name="View"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        items = [item.text or "" for item in element.findall("value")]
        if not items and element.text:
            items = [element.text]
        logger.debug("Leaving function "+str(function_name))
        return cls(elements=items)

class Window:
    statement_name = "window"
    xml_tag = "window"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="Window"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "Window":
        function_name = sys._getframe().f_code.co_name
        class_name="Window"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "Window":
        function_name = sys._getframe().f_code.co_name
        class_name="Window"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class ZeroNoSoaTtl:
    statement_name = "zero-no-soa-ttl"
    xml_tag = "zero_no_soa_ttl"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ZeroNoSoaTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "ZeroNoSoaTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="ZeroNoSoaTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ZeroNoSoaTtl":
        function_name = sys._getframe().f_code.co_name
        class_name="ZeroNoSoaTtl"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

class ZeroNoSoaTtlCache:
    statement_name = "zero-no-soa-ttl-cache"
    xml_tag = "zero_no_soa_ttl_cache"
    def __init__(self, value: Optional[str] = None) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    def set_value(self, value: Optional[str]) -> None:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        self.value = value

        logger.debug("Leaving function "+str(function_name))
    @classmethod
    def fromText(cls, text: str):
        function_name = sys._getframe().f_code.co_name
        class_name="ZeroNoSoaTtlCache"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        cleaned = (text or "").strip()
        if cleaned.endswith(";"):
            cleaned = cleaned[:-1].strip()
        if hasattr(cls, "ALLOWED_STATEMENTS"):
            body = _extract_statement_body(cleaned)
            statements = {}
            for chunk in _split_statement_texts(body):
                name = chunk.split(None, 1)[0] if chunk.split() else ""
                if not name:
                    continue
                if name in cls.ALLOWED_STATEMENTS:
                    stmt_cls = _statement_class_for_name(name)
                    if stmt_cls is None or not hasattr(stmt_cls, "fromText"):
                        continue
                    stmt_obj = stmt_cls.fromText(chunk + ";")
                    statements.setdefault(name, []).append(stmt_obj)
            try:
                logger.debug("Leaving function "+str(function_name))
                return cls(statements=statements)
            except TypeError:
                logger.debug("Leaving function "+str(function_name))
                return cls()
        if _class_accepts_param(cls, "elements"):
            body = _extract_statement_body(cleaned)
            elements = _split_statement_texts(body)
            logger.debug("Leaving function "+str(function_name))
            return cls(elements=elements)
        value = cleaned
        if hasattr(cls, "statement_name") and cleaned.startswith(cls.statement_name):
            value = cleaned[len(cls.statement_name):].strip()
        if value == "":
            value = None
        if _class_accepts_param(cls, "value"):
            logger.debug("Leaving function "+str(function_name))
            return cls(value=value)
        logger.debug("Leaving function "+str(function_name))
        return cls()
    def to_dict(self) -> dict:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        logger.debug("Leaving function "+str(function_name))
        return {"value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> "ZeroNoSoaTtlCache":
        function_name = sys._getframe().f_code.co_name
        class_name="ZeroNoSoaTtlCache"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if isinstance(data, str) or data is None:
            logger.debug("Leaving function "+str(function_name))
            return cls(value=data)
        logger.debug("Leaving function "+str(function_name))
        return cls(value=data.get("value"))

    def to_xml_element(self) -> ET.Element:
        function_name = sys._getframe().f_code.co_name
        class_name=self.__class__.__name__
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        element = ET.Element(self.xml_tag)
        if self.value is not None:
            element.text = str(self.value)
        logger.debug("Leaving function "+str(function_name))
        return element

    @classmethod
    def from_xml_element(cls, element: Optional[ET.Element]) -> "ZeroNoSoaTtlCache":
        function_name = sys._getframe().f_code.co_name
        class_name="ZeroNoSoaTtlCache"
        function_name=class_name+"."+function_name
        logger.debug("Entering function "+str(function_name))
        if element is None:
            logger.debug("Leaving function "+str(function_name))
            return cls()
        logger.debug("Leaving function "+str(function_name))
        return cls(value=element.text)

